"use strict";var g=require("execa");const o=async(s,e=[])=>await g.execa("git",[s,...e]),f=(s,{allowEmpty:e=!1,keyid:t,sign:a=!1}={})=>{const n=[];if(a){const c="-S",r=typeof t=="string"&&t!==""?`${c}${t}`:c;n.push(r)}return e&&n.push("--allow-empty"),[...n,"-m",`${s}`]},p=async(s,e={})=>{const t=f(s,e);return await o("commit",t)},m=(s,{get:e=!1,list:t=!1,unset:a=!1,scope:n="local",value:c}={})=>{const r=[`--${n}`];return c!=null?r.push(`${s}`,`${c.toString()}`):e?r.push("--get",`${s}`):a?r.push("--unset",`${s}`):t&&r.push("--list"),r},l=async(s,e)=>{const t=m(s,e);return await o("config",t)},y=async(s,e="local")=>{const{stdout:t}=await l(s,{get:!0,scope:e});if(t==="false")return!1;if(t==="true")return!0;const a=Number(t);return Number.isNaN(a)?t:a},d=async(s,e,t="local")=>await l(s,{scope:t,value:e}),w=(s,{tags:e=!1}={})=>{const t=[];let a="";return e===!0&&t.push("--tags"),typeof e=="string"&&(a=e),[...t,s,a]},$=async(s,e={})=>{const t=w(s,e);return await o("ls-remote",t)},h=(s,{delete:e=!1,remote:t="origin",signed:a=!1}={})=>{const n=[t,s];return e?[t,"-d",s]:(a!==!1&&n.push(`--signed=${a}`),n)},b=async(s,e={})=>{const t=h(s,e);return await o("push",t)},v=(s,{commit:e,delete:t=!1,list:a=!1,message:n="",sign:c=!1}={})=>{if(t)return["-d",s];if(a===!0)return["-l"];if(typeof a=="string")return["-l",a];const r=[];return c&&r.push("-s"),r.push(s),e!==void 0&&r.push(e),[...r,"-m",`${n}`]},R=async(s,e={})=>{const t=v(s,e);return await o("tag",t)},C=s=>({value:s,enumerable:!0,configurable:!1,writable:!1}),E=(s,e)=>{Object.keys(e).forEach(t=>{const a=C(e[t]);Object.defineProperty(s,t,a)})};E(o,{commit:p,config:l,getConfig:y,setConfig:d,lsRemote:$,push:b,tag:R});const N=(s,e)=>e.split(".").reduce((t,a)=>t?.[a],s),u=(s,e="")=>[...e.matchAll(/{(.*?)}/g)].map(t=>t[1]).reduce((t,a)=>{const n=N(s,a);return t.replace(`{${a}}`,`${n}`)},e),x=({branch:s,nextRelease:e})=>({branch:s.name,version:e.version,tag:e.gitTag,notes:e.notes??""}),P=async({commit:s={},tag:e={}}={},t)=>{const{branch:a,tag:n}=x(t),c=u(t,s.message??""),r=u(t,e.message??"");await o.commit(c,{sign:s.sign??!1,allowEmpty:s.allowEmpty??!1}),await o.push(a),await o.tag(n,{delete:!0}),await o.tag(n,{sign:e.sign??!1,message:r}),await o.push(n,{delete:!0}),await o.push(n)},i=async(s,e={})=>{const t=e?.nextRelease?.gitTag??"undefined";console.log(`----------${s}:`,t);const a=await o.tag("",{list:t});console.log("----------list local tags----------"),console.log("stderr:",a.stderr),console.log("stdout:",a.stdout),console.log("----------check remtoe tag----------");const n=await o.lsRemote("origin",{tags:t});console.log("stderr:",n.stderr),console.log("stdout:",n.stdout),console.log(`----------${s}----------done!`)},k=async(s={},e={})=>{await i("verifyConditions",e)},A=async(s={},e={})=>{await i("analyzeCommits",e)},T=async(s={},e={})=>{await i("verifyRelease",e)},j=async(s={},e={})=>{await i("generateNotes",e)},z=async(s={},e={})=>{await i("addChannel",e)},O=async(s={},e={})=>{await i("prepare",e);const t=e?.nextRelease?.gitTag??"coba-coba";console.log("----------PREPARE----------",t),await o.tag(t,{sign:!0,message:`dari PREPARE ${t} !`}),await o.push(t),await i("prepare",e)},S=async(s={},e={})=>{await i("success",e)},q=async(s={},e={})=>{await i("fail",e)};exports.addChannel=z,exports.analyzeCommits=A,exports.fail=q,exports.generateNotes=j,exports.prepare=O,exports.publish=P,exports.success=S,exports.verifyConditions=k,exports.verifyRelease=T;

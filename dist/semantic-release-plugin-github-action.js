"use strict";var g=require("execa");const r=async(s,e=[])=>await g.execa("git",[s,...e]),f=(s,{allowEmpty:e=!1,keyid:t,sign:a=!1}={})=>{const n=[];if(a){const c="-S",o=typeof t=="string"&&t!==""?`${c}${t}`:c;n.push(o)}return e&&n.push("--allow-empty"),[...n,"-m",`${s}`]},m=async(s,e={})=>{const t=f(s,e);return await r("commit",t)},p=(s,{get:e=!1,list:t=!1,unset:a=!1,scope:n="local",value:c}={})=>{const o=[`--${n}`];return c!=null?o.push(`${s}`,`${c.toString()}`):e?o.push("--get",`${s}`):a?o.push("--unset",`${s}`):t&&o.push("--list"),o},l=async(s,e)=>{const t=p(s,e);return await r("config",t)},y=async(s,e="local")=>{const{stdout:t}=await l(s,{get:!0,scope:e});if(t==="false")return!1;if(t==="true")return!0;const a=Number(t);return Number.isNaN(a)?t:a},d=async(s,e,t="local")=>await l(s,{scope:t,value:e}),w=(s,{tags:e=!1}={})=>{const t=[];let a="";return e===!0&&t.push("--tags"),typeof e=="string"&&(a=e),[...t,s,a]},h=async(s,e={})=>{const t=w(s,e);return await r("ls-remote",t)},$=(s,{delete:e=!1,remote:t="origin",signed:a=!1}={})=>{const n=[t,s];return e?[t,"-d",s]:(a!==!1&&n.push(`--signed=${a}`),n)},v=async(s,e={})=>{const t=$(s,e);return await r("push",t)},b=(s,{commit:e,delete:t=!1,list:a=!1,message:n="",sign:c=!1}={})=>{if(t)return["-d",s];if(a===!0)return["-l"];if(typeof a=="string")return["-l",a];const o=[];return c&&o.push("-s"),o.push(s),e!==void 0&&o.push(e),[...o,"-m",`${n}`]},C=async(s,e={})=>{const t=b(s,e);return await r("tag",t)},N=s=>({value:s,enumerable:!0,configurable:!1,writable:!1}),R=(s,e)=>{Object.keys(e).forEach(t=>{const a=N(e[t]);Object.defineProperty(s,t,a)})};R(r,{commit:m,config:l,getConfig:y,setConfig:d,lsRemote:h,push:v,tag:C});const x=(s,e)=>e.split(".").reduce((t,a)=>t?.[a],s),u=(s,e="")=>[...e.matchAll(/{(.*?)}/g)].map(t=>t[1]).reduce((t,a)=>{const n=x(s,a);return t.replace(`{${a}}`,`${n}`)},e),E=({branch:s,nextRelease:e})=>({branch:s.name,version:e.version,tag:e.gitTag,notes:e.notes??""}),k=async({commit:s={},tag:e={}}={},t)=>{const{branch:a,tag:n}=E(t),c=u(t,s.message??""),o=u(t,e.message??"");await r.commit(c,{sign:s.sign??!1,allowEmpty:s.allowEmpty??!1}),await r.push(a),await r.tag(n,{delete:!0}),await r.tag(n,{sign:e.sign??!1,message:o}),await r.push(n,{delete:!0}),await r.push(n)},i=async(s,e={})=>{const t=e?.nextRelease?.gitTag??"undefined";console.log(`----------${s}:`,t);const a=await r.tag("",{list:t});console.log("----------list local tags----------"),console.log("stderr:",a.stderr),console.log("stdout:",a.stdout),console.log("----------check remtoe tag----------");const n=await r.lsRemote("origin",{tags:t});console.log("stderr:",n.stderr),console.log("stdout:",n.stdout),console.log(`----------${s}----------done!`)},j=async(s={},e={})=>{await i("verifyConditions",e)},z=async(s={},e={})=>{await i("analyzeCommits",e)},O=async(s={},e={})=>{await i("verifyRelease",e)},S=async(s={},e={})=>{await i("generateNotes",e)},T=async(s={},e={})=>{await i("addChannel",e)},q=async(s={},e={})=>{await i("prepare",e)},A=async(s={},e={})=>{await i("success",e)},P=async(s={},e={})=>{await i("fail",e)};exports.addChannel=T,exports.analyzeCommits=z,exports.fail=P,exports.generateNotes=S,exports.prepare=q,exports.publish=k,exports.success=A,exports.verifyConditions=j,exports.verifyRelease=O;

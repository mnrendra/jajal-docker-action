"use strict";var g=require("execa");const o=async(s,e=[])=>await g.execa("git",[s,...e]),f=(s,{allowEmpty:e=!1,keyid:t,sign:a=!1}={})=>{const n=[];if(a){const r="-S",i=typeof t=="string"&&t!==""?`${r}${t}`:r;n.push(i)}return e&&n.push("--allow-empty"),[...n,"-m",`${s}`]},m=async(s,e={})=>{const t=f(s,e);return await o("commit",t)},p=(s,{get:e=!1,list:t=!1,unset:a=!1,scope:n="local",value:r}={})=>{const i=[`--${n}`];return r!=null?i.push(`${s}`,`${r.toString()}`):e?i.push("--get",`${s}`):a?i.push("--unset",`${s}`):t&&i.push("--list"),i},l=async(s,e)=>{const t=p(s,e);return await o("config",t)},y=async(s,e="local")=>{const{stdout:t}=await l(s,{get:!0,scope:e});if(t==="false")return!1;if(t==="true")return!0;const a=Number(t);return Number.isNaN(a)?t:a},d=async(s,e,t="local")=>await l(s,{scope:t,value:e}),w=(s,{tags:e=!1}={})=>{const t=[];let a="";return e===!0&&t.push("--tags"),typeof e=="string"&&(a=e),[...t,s,a]},h=async(s,e={})=>{const t=w(s,e);return await o("ls-remote",t)},$=(s,{delete:e=!1,remote:t="origin",signed:a=!1}={})=>{const n=[t,s];return e?[t,"-d",s]:(a!==!1&&n.push(`--signed=${a}`),n)},v=async(s,e={})=>{const t=$(s,e);return await o("push",t)},b=(s,{commit:e,delete:t=!1,list:a=!1,message:n="",sign:r=!1}={})=>{if(t)return["-d",s];if(a===!0)return["-l"];if(typeof a=="string")return["-l",a];const i=[];return r&&i.push("-s"),i.push(s),e!==void 0&&i.push(e),[...i,"-m",`${n}`]},R=async(s,e={})=>{const t=b(s,e);return await o("tag",t)},C=s=>({value:s,enumerable:!0,configurable:!1,writable:!1}),E=(s,e)=>{Object.keys(e).forEach(t=>{const a=C(e[t]);Object.defineProperty(s,t,a)})};E(o,{commit:m,config:l,getConfig:y,setConfig:d,lsRemote:h,push:v,tag:R});const N=(s,e)=>e.split(".").reduce((t,a)=>t?.[a],s),u=(s,e="")=>[...e.matchAll(/{(.*?)}/g)].map(t=>t[1]).reduce((t,a)=>{const n=N(s,a);return t.replace(`{${a}}`,`${n}`)},e),x=({branch:s,nextRelease:e})=>({branch:s.name,version:e.version,tag:e.gitTag,notes:e.notes??""}),k=async({commit:s={},tag:e={}}={},t)=>{const{branch:a,tag:n}=x(t),r=u(t,s.message??""),i=u(t,e.message??"");await o.commit(r,{sign:s.sign??!1,allowEmpty:s.allowEmpty??!1}),await o.push(a),await o.tag(n,{delete:!0}),await o.tag(n,{sign:e.sign??!1,message:i}),await o.push(n,{delete:!0}),await o.push(n)},c=async(s,e={})=>{const t=e?.nextRelease?.gitTag??"undefined";console.log(`----------${s}:`,t);const a=await o.tag("",{list:t});console.log("----------list local tags----------"),console.log("stderr:",a.stderr),console.log("stdout:",a.stdout),console.log("----------check remtoe tag----------");const n=await o.lsRemote("origin",{tags:t});console.log("stderr:",n.stderr),console.log("stdout:",n.stdout),console.log(`----------${s}----------done!`)},S=async(s={},e={})=>{await c("verifyConditions",e)},T=async(s={},e={})=>{await c("analyzeCommits",e)},j=async(s={},e={})=>{await c("verifyRelease",e);const t=e?.nextRelease?.gitTag??"coba-coba";console.log("----------VERIFY RELEASE----------",t),await o.tag(t,{sign:!0,message:`dari verifyRelease ${t} !`}),await o.push(t),await c("verifyRelease",e)},z=async(s={},e={})=>{await c("generateNotes",e)},A=async(s={},e={})=>{await c("addChannel",e)},O=async(s={},e={})=>{await c("prepare",e)},q=async(s={},e={})=>{await c("success",e)},F=async(s={},e={})=>{await c("fail",e)};exports.addChannel=A,exports.analyzeCommits=T,exports.fail=F,exports.generateNotes=z,exports.prepare=O,exports.publish=k,exports.success=q,exports.verifyConditions=S,exports.verifyRelease=j;

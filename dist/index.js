#!/usr/bin/env node
"use strict";var w=require("node:process"),v=require("execa"),Q=require("semantic-release"),y=require("node:fs"),T=require("node:path");require("node:child_process");var C=require("node:os"),L=require("nanoid"),Z=require("openpgp"),ee=require("addressparser"),G=require("@actions/core");const te="/github/workspace",re=["alpha","beta","rc"],ne=["docs","style","refactor","perf","test","build","ci","chore","revert"],ie=re.map(e=>({name:e,prerelease:!0})),se=["+([0-9])?(.{+([0-9]),x}).x","main","next",...ie],oe=ne.map(e=>({type:e,release:"patch"})),ae="/action",ce=[["@semantic-release/commit-analyzer",{releaseRules:oe}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${ae}/@mnrendra/semantic-release-plugin-publish-github-action`,"@semantic-release/github"],ge={branches:se,plugins:ce,dryRun:!1,ci:!0},K=async(e=[])=>await v.execa("git",e),I=async(e,t=!1)=>{const r=["config","--get"];t&&r.push("--global"),r.push(e);const{stdout:n}=await K(r);return n==="true"?!0:n==="false"?!1:n},h=async(e,t,r=!1)=>{const n=["config"];r&&n.push("--global"),n.push(e,t),await K(n)},ue="gpg-agent.conf",le={RELOADAGENT:"RELOADAGENT"},M=".gnupg",pe={WIN32:"win32"},fe=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,b=async e=>{const{stdout:t}=await v.execa("gpg-connect-agent",[`"${e}"`,"/bye"]);return t},Ge=async(e,t)=>{const r=T.join(e,ue);y.writeFileSync(r,t),await b(le.RELOADAGENT)},$=async(e=[],t={})=>await v.execa("gpg",e,t),de=async e=>{const t=["--batch","--yes",e],r=n=>[...t.slice(0,2),n,...t.slice(-1)];await $(r("--delete-secret-keys")),await $(r("--delete-keys"))},we=async(e=[])=>await v.execa("gpgconf",e),m={cwd:w.cwd(),verbose:!1},x=e=>{Object.keys(e).forEach(t=>{m[t]=e[t]})},k=(e,t,r="\x1B[39m")=>e.split(`
`).map(n=>(n=t+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),A=e=>{m.verbose&&console.log(k(e,"\x1B[90m"))},i=e=>{m.verbose&&console.log(e)},ye=e=>{if(typeof e=="function")return e;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&typeof e.default=="function")return e.default;throw new Error("Invalid module")},H=()=>{const e=w.cwd(),t=m.cwd;e!==t&&(i("---------------- Restore working directory -----------------------"),w.chdir(t),i(`Restore working directory to ${t}.`))},R=(e,t=!1)=>e.split(/\n\r|\r\n|\r|\n/).map(r=>t?r.trim():r),O=e=>{m.verbose&&console.log(k(e,"\x1B[32m"))},me=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid fingerprint value",{cause:e});return e}},$e=(e="local")=>{if(typeof e!="string"||!["global","local"].includes(e))throw new Error("Invalid gitScope value",{cause:e});return e},Ie=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignCommit value",{cause:e});return e},he=(e=!1)=>{if(typeof e!="boolean"&&(typeof e!="string"||e!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:e});return e},Ee=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignTag value",{cause:e});return e},Se=(e=!0)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignUser value",{cause:e});return e},ve=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid passphrase value",{cause:e});return e}},Te=e=>{if(e===void 0)return;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error("Invalid trustLevel value",{cause:e});return e},Pe=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid verbose value",{cause:e});return e},_e=e=>{try{return y.statSync(e).isDirectory()}catch{return!1}},Ne=(e=".")=>{if(typeof e!="string"||e==="")throw new Error("Invalid workdir value",{cause:e});if(!_e(e))throw new Error(`workdir ${e} is doesn't exist`,{cause:e});return e},be=e=>{if(typeof e!="object"||e===null||Array.isArray(e))throw new Error("Invalid options value",{cause:e});const t=Ne(e.workdir),r=ve(e.passphrase),n=me(e.fingerprint),s=Te(e.trustLevel),o=$e(e.gitScope),u=Se(e.gitSignUser),l=Ie(e.gitSignCommit),a=Ee(e.gitSignTag),c=he(e.gitSignPush),f=Pe(e.verbose);return x({...m,verbose:f}),i("---------------- importGPG's options to use ---------------------"),i(`workdir         : ${t}`),i(`passphrase      : ${r}`),i(`fingerprint     : ${n}`),i(`trustLevel      : ${s}`),i(`gitScope        : ${o}`),i(`gitSignUser     : ${u}`),i(`gitSignCommit   : ${l}`),i(`gitSignTag      : ${a}`),i(`gitSignPush     : ${c}`),i(`verbose         : ${f}`),{workdir:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:o,gitSignUser:u,gitSignCommit:l,gitSignTag:a,gitSignPush:c,verbose:f}},W=e=>{if(m.verbose){const t="\x1B[33m";console.log(k("WARNING:",t)),console.log(k(e,t))}},ke=(e,t)=>e.slice(t.length+1).replace("%3a",":").trim(),D=async()=>{const{stdout:e}=await we(["--list-dirs"]),t=R(e,!0),r={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(n=>{Object.keys(r).forEach(s=>{const o=s;n.startsWith(`${o}:`)&&(r[o]=ke(n,o))})}),Object.keys(r).forEach(n=>{const s=r[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),r},Re=async()=>{const{GNUPGHOME:e,HOME:t,USERPROFILE:r}=w.env;if(typeof e=="string"&&e!=="")return e;if(typeof t=="string"&&t!=="")return T.join(t,M);if(typeof r=="string"&&r!==""&&C.platform()===pe.WIN32)return T.join(r,M);const{homedir:n}=await D();return n},Ae=async()=>{const e=await Re();if(e.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:e});return y.existsSync(e)||y.mkdirSync(e,{recursive:!0}),e},Oe=(e,t)=>{let r="",n=!1;const s=R(e,!0);for(const o of s){if(o.startsWith("fpr:")&&o.includes(`:${t}:`)){n=!0;continue}if(o.startsWith("grp:")&&n){r=o.replace(/(grp|:)/g,"").trim();break}}return r},Ue=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await $(t);return Oe(r,e)},Ce=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await $(t),n=R(r,!0),s=[];return n.forEach(o=>{o.startsWith("grp")&&s.push(o.replace(/(grp|:)/g,"").trim())}),s},U=(e,t)=>e.slice(t.length+1).trim(),Le=async()=>{const e=["--version"],{stdout:t}=await $(e),r=R(t,!0),n={gnupg:"",libgcrypt:""};return r.forEach(s=>{s.startsWith("gpg (GnuPG) ")?n.gnupg=U(s,"gpg (GnuPG)"):s.startsWith("gpg (GnuPG/MacGPG2) ")?n.gnupg=U(s,"gpg (GnuPG/MacGPG2)"):s.startsWith("libgcrypt ")&&(n.libgcrypt=U(s,"libgcrypt"))}),Object.keys(n).forEach(s=>{const o=n[s];if(typeof o!="string"||o==="")throw new Error(`Invalid GPG ${s}`,{cause:o})}),n},Ke=e=>e.trimStart().startsWith("---"),F=e=>Ke(e)?e:Buffer.from(e,"base64").toString(),Me=async e=>{const t=F(e),r=await Z.readKey({armoredKey:t}),{user:n}=await r.getPrimaryUser(),s=r.getFingerprint().toUpperCase(),o=r.getKeyID().toHex().toUpperCase(),u=ye(ee),{name:l,address:a}=u(n.userID?.userID??"")[0],c=r.getCreationTime();return{digest:s,id:o,name:l,email:a,creationTime:c}},xe=async e=>{const t=T.join(C.tmpdir(),`mnrendra-import-gpg-${L.nanoid()}`),r=y.mkdtempSync(t),n=`${r}/${L.nanoid()}.pgp`,s=F(e);y.writeFileSync(n,s,{mode:384});const o=["--import","--batch","--yes",n],{stdout:u,stderr:l}=await $(o);return l!==""?l:(y.unlinkSync(n),y.rmSync(r),u)},He=async()=>{await b("KILLAGENT")},j=async(e,t)=>{const r=Buffer.from(t,"utf8").toString("hex").toUpperCase();return await b(`PRESET_PASSPHRASE ${e} -1 ${r}`),await b(`KEYINFO ${e}`)},We=async(e,t)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",e],n=Buffer.from(`trust
${t}
y
quit
`);await $(r,{input:n})},q="user.signingkey",V="user.name",B="user.email",Y="commit.gpgsign",z="tag.gpgsign",X="push.gpgsign",De=async(e,t,r,{scope:n,signUser:s,signCommit:o,signTag:u,signPush:l})=>{i("---------------- Configuring Git ---------------------------------");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""},c=n==="global";return a.scope=n,i(`scope           : ${a.scope}`),s&&(await h(q,e,c),a.userSigningkey=await I(q,c),i(`user.signingkey : ${a.userSigningkey}`),await h(V,t,c),a.userName=await I(V,c),i(`user.name       : ${a.userName}`),await h(B,r,c),a.userEmail=await I(B,c),i(`user.email      : ${a.userEmail}`)),o&&(await h(Y,`${o}`,c),a.commitGpgsign=await I(Y,c),i(`commit.gpgsign  : ${a.commitGpgsign}`)),u&&(await h(z,`${u}`,c),a.tagGpgsign=await I(z,c),i(`tag.gpgsign     : ${a.tagGpgsign}`)),l!==!1&&(await h(X,`${l}`,c),a.pushGpgsign=await I(X,c),i(`push.gpgsign    : ${a.pushGpgsign}`)),a},Fe=async(e,t,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const s=await Ae();if(await Ge(s,fe),n.gpgHome=s,i("---------------- Configuring GnuPG agent -------------------------"),i(`GnuPG home      : ${s}`),t!==void 0){i("---------------- Getting keygrip for fingerprint -----------------");const o=await Ue(t);i(`Presetting passphrase for key ${t} with keygrip ${o}`);const u=await j(o,r);A(u),n.keygrips=[o]}else{i("---------------- Getting keygrips --------------------------------");const o=await Ce(e);for(const u of o){i(`Presetting passphrase for ${u}`);const l=await j(u,r);A(l)}n.keygrips=o}return n},je=async()=>{const e=await Le(),t=await D(),r={...e,...t};Object.keys(r).forEach(s=>{const o=r[s];if(typeof o!="string"&&o==="")throw new Error(`Invalid GPG ${s} value`,{cause:o})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return i("---------------- GnuPG info --------------------------------------"),i(`Version         : ${n}`),i(`Libdir          : ${r.libdir}`),i(`Libexecdir      : ${r.libexecdir}`),i(`Datadir         : ${r.datadir}`),i(`Homedir         : ${r.homedir}`),{...r,version:n}},qe=async e=>{const{digest:t,id:r,name:n,email:s,creationTime:o}=await Me(e);return i("---------------- GPG private key info ----------------------------"),i(`Fingerprint     : ${t}`),i(`KeyID           : ${r}`),i(`Name            : ${n}`),i(`Email           : ${s}`),i(`CreationTime    : ${o.toUTCString()}`),{digest:t,id:r,name:n,email:s,creationTime:o}},Ve=async(e,t)=>{i("---------------- Importing GPG private key -----------------------");const r=await xe(e);return i(r),r},Be=(e,t)=>{i("---------------- Fingerprint to use ------------------------------"),i(t??e)},Ye=async(e,t)=>{if(t===void 0)return"";const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:t});return i("---------------- Setting key's trust level ----------------------"),await We(e,t),i(`Trust level set to ${t} for ${e}`),`Trust level set to ${t} for ${e}`},ze=async e=>{const t=w.cwd();x({...m,cwd:t});const r=T.resolve(e);t!==r&&(i("---------------- Change working directory ------------------------"),w.chdir(r),i(`Using ${r} as working directory...`))},Xe=async(e,t={})=>{try{if(typeof e!="string"||e==="")throw new Error("Invalid GnuPG private key",{cause:e});const r=be(t),{workdir:n,fingerprint:s,passphrase:o,trustLevel:u}=r;await ze(n);const l=await je(),a=await qe(e),{digest:c,id:f,name:P,email:E}=a;Be(c,s);const S=await Ve(e),_=await Fe(c,s,o);await Ye(f,u),O("---------------- Successfully set up GPG key ---------------------");const N={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},p=await De(f,P,E,N);O("---------------- Successfully configured Git ---------------------");const J={...l,...a,..._,...p,keyid:f,fingerprint:s??c,log:S,trustLevel:u,gitConfigScope:p.scope,gitUserSigningkey:p.userSigningkey,gitUserName:p.userName,gitUserEmail:p.userEmail,gitCommitGpgsign:p.commitGpgsign,gitTagGpgsign:p.tagGpgsign,gitPushGpgsign:p.pushGpgsign,workdir:w.cwd()};return H(),J}catch(r){throw H(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},Je=async(e="")=>{if(e.length<=0){A("Primary key fingerprint is not defined. Skipping cleanup.");return}try{i("---------------- Cleaning up GPG key -----------------------------"),i(`Removing key ${e}`),await de(e),i("Killing GnuPG agent"),await He(),O("---------------- Successfully cleaned up GPG key -----------------")}catch(t){const r=t instanceof Error?t.message:"Unknown error";W(r),W(`${t}`)}},d=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:w.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),Qe=()=>{const e=G.getInput(g.GPG_FINGERPRINT);if(e===void 0||e==="")return d.GPG_FINGERPRINT;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:e});return e},Ze=()=>{const e=G.getInput(g.GIT_SCOPE);if(e===void 0||e==="")return d.GIT_SCOPE;if(typeof e!="string"||!["global","local"].includes(e))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:e});return e},et=()=>{const e=G.getInput(g.GIT_SIGN_COMMIT);if(e===void 0||e==="")return d.GIT_SIGN_COMMIT;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:e})}},tt=()=>{const e=G.getInput(g.GIT_SIGN_PUSH);if(e===void 0||e==="")return d.GIT_SIGN_PUSH;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:e})}},rt=()=>{const e=G.getInput(g.GIT_SIGN_TAG);if(e===void 0||e==="")return d.GIT_SIGN_TAG;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:e})}},nt=()=>{const e=G.getInput(g.GIT_SIGN_USER);if(e===void 0||e==="")return d.GIT_SIGN_USER;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:e})}},it=()=>{const e=G.getInput(g.GPG_PASSPHRASE);if(e===void 0||e==="")return d.GPG_PASSPHRASE;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:e});return e},st=()=>{const e=G.getInput(g.GPG_PRIVATE_KEY);if(e===void 0||e==="")return d.GPG_PRIVATE_KEY;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:e});return e},ot=()=>{const e=G.getInput(g.TOKEN);if(e===void 0||e==="")return d.TOKEN;if(typeof e!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:e});return e},at=()=>{const e=G.getInput(g.GPG_TRUST_LEVEL);if(e===void 0||e==="")return d.GPG_TRUST_LEVEL;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:e});return t},ct=()=>{const e=G.getInput(g.WORKDIR);if(e===void 0||e==="")return d.WORKDIR;if(typeof e!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:e});return e},gt=()=>{const e=Qe(),t=Ze(),r=et(),n=tt(),s=rt(),o=nt(),u=it(),l=st(),a=ot(),c=at(),f=ct();return{fingerprint:e,gitScope:t,gitSignCommit:r,gitSignPush:n,gitSignTag:s,gitSignUser:o,passphrase:u,privateKey:l,token:a,trustLevel:c,workdir:f}},ut=e=>{if(typeof e=="function")return e;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&typeof e.default=="function")return e.default;throw new Error("Invalid module")},lt=async()=>{await v.execa("git",["config","--global","--add","safe.directory",te]);const{workdir:e,privateKey:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:o,gitSignUser:u,gitSignCommit:l,gitSignTag:a,gitSignPush:c,token:f}=gt();let P="",E="GitOps Release",S="gitops-release@users.noreply.github.com",_=w.cwd();if(t!==void 0){const p=await Xe(t,{workdir:e,passphrase:r,fingerprint:n,trustLevel:s,gitScope:o,gitSignUser:u,gitSignCommit:l,gitSignTag:a,gitSignPush:c,verbose:!0});P=p.digest,E=p.name,S=p.email,_=p.workdir}const N=await ut(Q)(ge,{env:{...w.env,GIT_AUTHOR_NAME:E,GIT_AUTHOR_EMAIL:S,GIT_COMMITTER_NAME:E,GIT_COMMITTER_EMAIL:S,GITHUB_TOKEN:f}});return N!==!1?console.log("release:",N.nextRelease.version):console.warn("failed to release!"),await Je(P),_};lt().then(e=>{console.log("hasil:",e)}).catch(e=>{throw e instanceof Error?e:new Error("Unknown error")});

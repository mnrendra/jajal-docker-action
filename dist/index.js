#!/usr/bin/env node
"use strict";var G=require("node:process"),I=require("execa"),te=require("semantic-release"),y=require("node:fs"),E=require("node:path"),U=require("node:os"),A=require("nanoid"),re=require("openpgp"),ne=require("addressparser"),l=require("@actions/core");const se="/github/workspace",C=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)&&"__esModule"in e&&e.__esModule===!0&&"default"in e?e.default:e,_=e=>`\x1B[${e}m`,ie=_(32),oe=_(33),ae=_(90),N=(e,t,r="\x1B[39m")=>e.split(`
`).map(n=>(n=t+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),L=e=>{console.log(N(e,oe))},b=e=>{console.log(N(e,ie))},k=e=>{console.log(N(e,ae))},o=e=>{console.log(e)},ce="gpg-agent.conf",M=".gnupg",ge={WIN32:"win32"},ue=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,v=async e=>{const{stdout:t}=await I.execa("gpg-connect-agent",[e,"/bye"]);return t},le=async(e,t)=>{const r=E.join(e,ce);y.writeFileSync(r,t),await v("RELOADAGENT")},$=async(e=[],t={})=>await I.execa("gpg",e,t),pe=async e=>{const t=["--batch","--yes",e],r=n=>[...t.slice(0,2),n,...t.slice(-1)];await $(r("--delete-secret-keys")),await $(r("--delete-keys"))},fe=async(e=[])=>await I.execa("gpgconf",e),P={cwd:G.cwd(),verbose:!1},K=e=>{Object.keys(e).forEach(t=>{P[t]=e[t]})},H=()=>{const e=G.cwd(),t=P.cwd;e!==t&&(o("---------------- Restore working directory -----------------------"),G.chdir(t),o(`Restore working directory to ${t}.`))},T=(e,t=!1)=>e.split(/\n\r|\r\n|\r|\n/).map(r=>t?r.trim():r),Ge=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid fingerprint value",{cause:e});return e}},de=(e="local")=>{if(typeof e!="string"||!["global","local"].includes(e))throw new Error("Invalid gitScope value",{cause:e});return e},we=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignCommit value",{cause:e});return e},ye=(e=!1)=>{if(typeof e!="boolean"&&(typeof e!="string"||e!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:e});return e},$e=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignTag value",{cause:e});return e},me=(e=!0)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignUser value",{cause:e});return e},he=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid passphrase value",{cause:e});return e}},Ie=e=>{if(e===void 0)return;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error("Invalid trustLevel value",{cause:e});return e},Ee=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid verbose value",{cause:e});return e},Se=e=>{try{return y.statSync(e).isDirectory()}catch{return!1}},ve=(e=".")=>{if(typeof e!="string"||e==="")throw new Error("Invalid workdir value",{cause:e});if(!Se(e))throw new Error(`workdir ${e} is doesn't exist`,{cause:e});return e},Pe=e=>{if(typeof e!="object"||e===null||Array.isArray(e))throw new Error("Invalid options value",{cause:e});const t=ve(e.workdir),r=he(e.passphrase),n=Ge(e.fingerprint),s=Ie(e.trustLevel),i=de(e.gitScope),a=me(e.gitSignUser),u=we(e.gitSignCommit),c=$e(e.gitSignTag),f=ye(e.gitSignPush),d=Ee(e.verbose);return K({...P,verbose:d}),o("---------------- importGPG's options to use ---------------------"),o(`workdir         : ${t}`),o(`passphrase      : ${r}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${s}`),o(`gitScope        : ${i}`),o(`gitSignUser     : ${a}`),o(`gitSignCommit   : ${u}`),o(`gitSignTag      : ${c}`),o(`gitSignPush     : ${f}`),o(`verbose         : ${d}`),{workdir:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:a,gitSignCommit:u,gitSignTag:c,gitSignPush:f,verbose:d}},Te=(e,t)=>e.slice(t.length+1).replace("%3a",":").trim(),x=async()=>{const e=["--list-dirs"],{stdout:t}=await fe(e),r=T(t,!0),n={libdir:"",libexecdir:"",datadir:"",homedir:""};return r.forEach(s=>{Object.keys(n).forEach(i=>{const a=i;s.startsWith(`${a}:`)&&(n[a]=Te(s,a))})}),Object.keys(n).forEach(s=>{const i=n[s];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${s}`,{cause:i})}),n},_e=async()=>{const{GNUPGHOME:e,HOME:t,USERPROFILE:r}=G.env;if(typeof e=="string"&&e!=="")return e;if(typeof t=="string"&&t!=="")return E.join(t,M);if(typeof r=="string"&&r!==""&&U.platform()===ge.WIN32)return E.join(r,M);const{homedir:n}=await x();return n},Ne=async()=>{const e=await _e();if(e.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:e});return y.existsSync(e)||y.mkdirSync(e,{recursive:!0}),e},be=(e,t)=>{let r="",n=!1;const s=T(e,!0);for(const i of s){if(i.startsWith("fpr:")&&i.includes(`:${t}:`)){n=!0;continue}if(i.startsWith("grp:")&&n){r=i.replace(/(grp|:)/g,"").trim();break}}return r},ke=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await $(t);return be(r,e)},Re=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await $(t),n=T(r,!0),s=[];return n.forEach(i=>{i.startsWith("grp")&&s.push(i.replace(/(grp|:)/g,"").trim())}),s},R=(e,t)=>e.slice(t.length+1).trim(),Oe=async()=>{const e=["--version"],{stdout:t}=await $(e),r=T(t,!0),n={gnupg:"",libgcrypt:""};return r.forEach(s=>{s.startsWith("gpg (GnuPG) ")?n.gnupg=R(s,"gpg (GnuPG)"):s.startsWith("gpg (GnuPG/MacGPG2) ")?n.gnupg=R(s,"gpg (GnuPG/MacGPG2)"):s.startsWith("libgcrypt ")&&(n.libgcrypt=R(s,"libgcrypt"))}),Object.keys(n).forEach(s=>{const i=n[s];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${s}`,{cause:i})}),n},Ue=e=>e.trimStart().startsWith("---"),W=e=>Ue(e)?e:Buffer.from(e,"base64").toString(),Ae=async e=>{const t=W(e),r=await re.readKey({armoredKey:t}),{user:n}=await r.getPrimaryUser(),s=r.getFingerprint().toUpperCase(),i=r.getKeyID().toHex().toUpperCase(),a=C(ne),{name:u,address:c}=a(n.userID?.userID??"")[0],f=r.getCreationTime();return{digest:s,id:i,name:u,email:c,creationTime:f}},Ce=async e=>{const t=E.join(U.tmpdir(),`mnrendra-import-gpg-${A.nanoid()}`),r=y.mkdtempSync(t),n=`${r}/${A.nanoid()}.pgp`,s=W(e);y.writeFileSync(n,s,{mode:384});const i=["--import","--batch","--yes",n],{stdout:a,stderr:u}=await $(i);return u!==""?u:(y.unlinkSync(n),y.rmSync(r),a)},Le=async()=>{await v("KILLAGENT")},j=async(e,t)=>{const r=Buffer.from(t,"utf8").toString("hex").toUpperCase();return await v(`PRESET_PASSPHRASE ${e} -1 ${r}`),await v(`KEYINFO ${e}`)},Me=async(e,t)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",e],n=Buffer.from(`trust
${t}
y
quit
`);await $(r,{input:n})},S=async(e,t=[])=>await I.execa("git",[e,...t]),Ke=(e,{allowEmpty:t=!1,keyid:r,sign:n=!1}={})=>{const s=[];if(n){const i="-S",a=typeof r=="string"&&r!==""?`${i}${r}`:i;s.push(a)}return t&&s.push("--allow-empty"),[...s,"-m",`${e}`]},He=async(e,t={})=>{const r=Ke(e,t);return await S("commit",r)},xe=(e,{get:t=!1,list:r=!1,unset:n=!1,scope:s="local",value:i}={})=>{const a=[`--${s}`];return i!=null?a.push(`${e}`,`${i.toString()}`):t?a.push("--get",`${e}`):n?a.push("--unset",`${e}`):r&&a.push("--list"),a},O=async(e,t)=>{const r=xe(e,t);return await S("config",r)},m=async(e,t="local")=>{const{stdout:r}=await O(e,{get:!0,scope:t});if(r==="false")return!1;if(r==="true")return!0;const n=Number(r);return Number.isNaN(n)?r:n},h=async(e,t,r="local")=>await O(e,{scope:r,value:t}),We=(e,{delete:t=!1,remote:r="origin",signed:n=!1}={})=>{const s=[r,e];return t?[r,"-d",e]:(n!==!1&&s.push(`--signed=${n}`),s)},je=async(e,t={})=>{const r=We(e,t);return await S("push",r)},Fe=(e,{commit:t,delete:r=!1,message:n="",sign:s=!1}={})=>{if(r)return["-d",e];const i=[];return s&&i.push("-s"),i.push(e),t!==void 0&&i.push(t),[...i,"-m",`${n}`]},De=async(e,t={})=>{const r=Fe(e,t);return await S("tag",r)},qe=e=>({value:e,enumerable:!0,configurable:!1,writable:!1}),Ve=(e,t)=>{Object.keys(t).forEach(r=>{const n=qe(t[r]);Object.defineProperty(e,r,n)})};Ve(S,{commit:He,config:O,getConfig:m,setConfig:h,push:je,tag:De});const F="user.signingkey",D="user.name",q="user.email",V="commit.gpgsign",B="tag.gpgsign",Y="push.gpgsign",Be=async(e,t,r,{scope:n,signUser:s,signCommit:i,signTag:a,signPush:u})=>{o("---------------- Configuring Git ---------------------------------");const c={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""};return c.scope=n,o(`scope           : ${c.scope}`),s&&(await h(F,e,n),c.userSigningkey=await m(F,n),o(`user.signingkey : ${c.userSigningkey}`),await h(D,t,n),c.userName=await m(D,n),o(`user.name       : ${c.userName}`),await h(q,r,n),c.userEmail=await m(q,n),o(`user.email      : ${c.userEmail}`)),i&&(await h(V,i,n),c.commitGpgsign=await m(V,n),o(`commit.gpgsign  : ${c.commitGpgsign}`)),a&&(await h(B,a,n),c.tagGpgsign=await m(B,n),o(`tag.gpgsign     : ${c.tagGpgsign}`)),u!==!1&&(await h(Y,u,n),c.pushGpgsign=await m(Y,n),o(`push.gpgsign    : ${c.pushGpgsign}`)),c},Ye=async(e,t,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const s=await Ne();if(await le(s,ue),n.gpgHome=s,o("---------------- Configuring GnuPG agent -------------------------"),o(`GnuPG home      : ${s}`),t!==void 0){o("---------------- Getting keygrip for fingerprint -----------------");const i=await ke(t);o(`Presetting passphrase for key ${t} with keygrip ${i}`);const a=await j(i,r);k(a),n.keygrips=[i]}else{o("---------------- Getting keygrips --------------------------------");const i=await Re(e);for(const a of i){o(`Presetting passphrase for ${a}`);const u=await j(a,r);k(u)}n.keygrips=i}return n},ze=async()=>{const e=await Oe(),t=await x(),r={...e,...t};Object.keys(r).forEach(s=>{const i=r[s];if(typeof i!="string"&&i==="")throw new Error(`Invalid GPG ${s} value`,{cause:i})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return o("---------------- GnuPG info --------------------------------------"),o(`Version         : ${n}`),o(`Libdir          : ${r.libdir}`),o(`Libexecdir      : ${r.libexecdir}`),o(`Datadir         : ${r.datadir}`),o(`Homedir         : ${r.homedir}`),{...r,version:n}},Xe=async e=>{const{digest:t,id:r,name:n,email:s,creationTime:i}=await Ae(e);return o("---------------- GPG private key info ----------------------------"),o(`Fingerprint     : ${t}`),o(`KeyID           : ${r}`),o(`Name            : ${n}`),o(`Email           : ${s}`),o(`CreationTime    : ${i.toUTCString()}`),{digest:t,id:r,name:n,email:s,creationTime:i}},Je=async(e,t)=>{o("---------------- Importing GPG private key -----------------------");const r=await Ce(e);return o(r),r},Qe=(e,t)=>{o("---------------- Fingerprint to use ------------------------------"),o(t??e)},Ze=async(e,t)=>{if(t===void 0)return"";const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:t});return o("---------------- Setting key's trust level ----------------------"),await Me(e,t),o(`Trust level set to ${t} for ${e}`),`Trust level set to ${t} for ${e}`},et=async e=>{const t=G.cwd();K({...P,cwd:t});const r=E.resolve(e);t!==r&&(o("---------------- Change working directory ------------------------"),G.chdir(r),o(`Using ${r} as working directory...`))},tt=async(e,t={})=>{try{if(typeof e!="string"||e==="")throw new Error("Invalid GnuPG private key",{cause:e});const r=Pe(t),{workdir:n,fingerprint:s,passphrase:i,trustLevel:a}=r;await et(n);const u=await ze(),c=await Xe(e),{digest:f,id:d,name:z,email:X}=c;Qe(f,s);const J=await Je(e),Q=await Ye(f,s,i);await Ze(d,a),b("---------------- Successfully set up GPG key ---------------------");const Z={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},w=await Be(d,z,X,Z);b("---------------- Successfully configured Git ---------------------");const ee={...u,...c,...Q,...w,keyid:d,fingerprint:s??f,log:J,trustLevel:a,gitConfigScope:w.scope,gitUserSigningkey:w.userSigningkey,gitUserName:w.userName,gitUserEmail:w.userEmail,gitCommitGpgsign:w.commitGpgsign,gitTagGpgsign:w.tagGpgsign,gitPushGpgsign:w.pushGpgsign,workdir:G.cwd()};return H(),ee}catch(r){throw H(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},rt=async(e="")=>{if(e.length<=0){k("Primary key fingerprint is not defined. Skipping cleanup.");return}try{o("---------------- Cleaning up GPG key -----------------------------"),o(`Removing key ${e}`),await pe(e),o("Killing GnuPG agent"),await Le(),b("---------------- Successfully cleaned up GPG key -----------------")}catch(t){const r=t instanceof Error?t.message:"Unknown error";L(r),L(`${t}`)}},nt=["alpha","beta","rc"],st=["docs","style","refactor","perf","test","build","ci","chore","revert"],it=nt.map(e=>({name:e,prerelease:!0})),ot=["+([0-9])?(.{+([0-9]),x}).x","main","next",...it],at=st.map(e=>({type:e,release:"patch"})),ct="/action",gt=[["@semantic-release/commit-analyzer",{releaseRules:at}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${ct}/@mnrendra/semantic-release-plugin-github-action`,"@semantic-release/github"],ut={branches:ot,plugins:gt,dryRun:!1,ci:!0},p=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:G.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),lt=()=>{const e=l.getInput(g.GPG_FINGERPRINT);if(e===void 0||e==="")return p.GPG_FINGERPRINT;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:e});return e},pt=()=>{const e=l.getInput(g.GIT_SCOPE);if(e===void 0||e==="")return p.GIT_SCOPE;if(typeof e!="string"||!["global","local"].includes(e))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:e});return e},ft=()=>{const e=l.getInput(g.GIT_SIGN_COMMIT);if(e===void 0||e==="")return p.GIT_SIGN_COMMIT;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:e})}},Gt=()=>{const e=l.getInput(g.GIT_SIGN_PUSH);if(e===void 0||e==="")return p.GIT_SIGN_PUSH;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:e})}},dt=()=>{const e=l.getInput(g.GIT_SIGN_TAG);if(e===void 0||e==="")return p.GIT_SIGN_TAG;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:e})}},wt=()=>{const e=l.getInput(g.GIT_SIGN_USER);if(e===void 0||e==="")return p.GIT_SIGN_USER;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:e})}},yt=()=>{const e=l.getInput(g.GPG_PASSPHRASE);if(e===void 0||e==="")return p.GPG_PASSPHRASE;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:e});return e},$t=()=>{const e=l.getInput(g.GPG_PRIVATE_KEY);if(e===void 0||e==="")return p.GPG_PRIVATE_KEY;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:e});return e},mt=()=>{const e=l.getInput(g.TOKEN);if(e===void 0||e==="")return p.TOKEN;if(typeof e!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:e});return e},ht=()=>{const e=l.getInput(g.GPG_TRUST_LEVEL);if(e===void 0||e==="")return p.GPG_TRUST_LEVEL;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:e});return t},It=()=>{const e=l.getInput(g.WORKDIR);if(e===void 0||e==="")return p.WORKDIR;if(typeof e!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:e});return e},Et=()=>{const e=lt(),t=pt(),r=ft(),n=Gt(),s=dt(),i=wt(),a=yt(),u=$t(),c=mt(),f=ht(),d=It();return{fingerprint:e,gitScope:t,gitSignCommit:r,gitSignPush:n,gitSignTag:s,gitSignUser:i,passphrase:a,privateKey:u,token:c,trustLevel:f,workdir:d}},St=async()=>{await I.execa("git",["config","--global","--add","safe.directory",se]);const e=Et();let t="",r="GitOps Release",n="gitops-release@users.noreply.github.com",s=G.cwd();const{privateKey:i,token:a}=e;if(i!==void 0){const c=await tt(i,{...e,verbose:!0});t=c.digest,r=c.name,n=c.email,s=c.workdir}const u=await C(te)(ut,{env:{...G.env,GIT_AUTHOR_NAME:r,GIT_AUTHOR_EMAIL:n,GIT_COMMITTER_NAME:r,GIT_COMMITTER_EMAIL:n,GITHUB_TOKEN:a}});return u!==!1?console.log("release:",u.nextRelease.version):console.warn("failed to release!"),await rt(t),s};St().then(e=>{console.log("hasil:",e)}).catch(e=>{throw e instanceof Error?e:new Error("Unknown error")});

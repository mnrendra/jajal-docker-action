#!/usr/bin/env node
"use strict";var w=require("node:process"),b=require("execa"),Z=require("semantic-release"),y=require("node:fs"),P=require("node:path"),ee=require("node:child_process"),C=require("node:os"),L=require("nanoid"),te=require("openpgp"),re=require("addressparser"),G=require("@actions/core");const ne="/github/workspace",se=["alpha","beta","rc"],ie=["docs","style","refactor","perf","test","build","ci","chore","revert"],oe=se.map(e=>({name:e,prerelease:!0})),ae=["+([0-9])?(.{+([0-9]),x}).x","main","next",...oe],ce=ie.map(e=>({type:e,release:"patch"})),ge="/action",ue=[["@semantic-release/commit-analyzer",{releaseRules:ce}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${ge}/@mnrendra/semantic-release-plugin-publish-github-action`,"@semantic-release/github"],le={branches:ae,plugins:ue,dryRun:!1,ci:!0},K=async(e=[])=>await b.execa("git",e),S=async(e,t=!1)=>{const r=["config","--get"];t&&r.push("--global"),r.push(e);const{stdout:n}=await K(r);return n==="true"?!0:n==="false"?!1:n},E=async(e,t,r=!1)=>{const n=["config"];r&&n.push("--global"),n.push(e,t),await K(n)},pe="gpg-agent.conf",M=".gnupg",fe={WIN32:"win32"},Ge=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,m={cwd:w.cwd(),verbose:!1},x=e=>{Object.keys(e).forEach(t=>{m[t]=e[t]})},k=(e,t,r="\x1B[39m")=>e.split(`
`).map(n=>(n=t+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),A=e=>{m.verbose&&console.log(k(e,"\x1B[90m"))},H=e=>e.trim().replace(/\r/g,"").trim().split(/\n/),de=(e,t=[],r={})=>new Promise((n,s)=>{try{const i=t.length>0?`${e} ${t.join(" ")}`:e;ee.exec(i,r,(c,l,a)=>{c!=null&&s(c);const g=l.trim(),p=H(g),$=a.trim(),h=H($);n({stdout:g,stdoutLines:p,stderr:$,stderrLines:h})})}catch(i){s(i)}}),o=e=>{m.verbose&&console.log(e)},we=e=>{if(typeof e=="function")return e;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&typeof e.default=="function")return e.default;throw new Error("Invalid module")},W=()=>{const e=w.cwd(),t=m.cwd;e!==t&&(o("---------------- Restore working directory -----------------------"),w.chdir(t),o(`Restore working directory to ${t}.`))},N=(e,t=!1)=>e.split(/\n\r|\r\n|\r|\n/).map(r=>t?r.trim():r),U=e=>{m.verbose&&console.log(k(e,"\x1B[32m"))},ye=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid fingerprint value",{cause:e});return e}},me=(e="local")=>{if(typeof e!="string"||!["global","local"].includes(e))throw new Error("Invalid gitScope value",{cause:e});return e},$e=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignCommit value",{cause:e});return e},he=(e=!1)=>{if(typeof e!="boolean"&&(typeof e!="string"||e!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:e});return e},Ie=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignTag value",{cause:e});return e},Se=(e=!0)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignUser value",{cause:e});return e},Ee=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid passphrase value",{cause:e});return e}},ve=e=>{if(e===void 0)return;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error("Invalid trustLevel value",{cause:e});return e},Pe=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid verbose value",{cause:e});return e},Te=e=>{try{return y.statSync(e).isDirectory()}catch{return!1}},_e=(e=".")=>{if(typeof e!="string"||e==="")throw new Error("Invalid workdir value",{cause:e});if(!Te(e))throw new Error(`workdir ${e} is doesn't exist`,{cause:e});return e},be=e=>{if(typeof e!="object"||e===null||Array.isArray(e))throw new Error("Invalid options value",{cause:e});const t=_e(e.workdir),r=Ee(e.passphrase),n=ye(e.fingerprint),s=ve(e.trustLevel),i=me(e.gitScope),c=Se(e.gitSignUser),l=$e(e.gitSignCommit),a=Ie(e.gitSignTag),g=he(e.gitSignPush),p=Pe(e.verbose);return x({...m,verbose:p}),o("---------------- importGPG's options to use ---------------------"),o(`workdir         : ${t}`),o(`passphrase      : ${r}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${s}`),o(`gitScope        : ${i}`),o(`gitSignUser     : ${c}`),o(`gitSignCommit   : ${l}`),o(`gitSignTag      : ${a}`),o(`gitSignPush     : ${g}`),o(`verbose         : ${p}`),{workdir:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:c,gitSignCommit:l,gitSignTag:a,gitSignPush:g,verbose:p}},j=e=>{if(m.verbose){const t="\x1B[33m";console.log(k("WARNING:",t)),console.log(k(e,t))}},R=async e=>{console.log("sususu-----",e);const{stdout:t}=await de(`gpg-connect-agent "${e}" /bye`);return t},ke=async(e,t)=>{const r=P.join(e,pe);y.writeFileSync(r,t);const n=await R("RELOADAGENT");console.log("susu----------reloadAgent:",n)},I=async(e=[],t={})=>await b.execa("gpg",e,t),Ne=async e=>{const t=["--batch","--yes",e],r=n=>[...t.slice(0,2),n,...t.slice(-1)];await I(r("--delete-secret-keys")),await I(r("--delete-keys"))},Re=async(e=[])=>await b.execa("gpgconf",e),Ae=(e,t)=>e.slice(t.length+1).replace("%3a",":").trim(),F=async()=>{const e=["--list-dirs"],{stdout:t}=await Re(e),r=N(t,!0),n={libdir:"",libexecdir:"",datadir:"",homedir:""};return r.forEach(s=>{Object.keys(n).forEach(i=>{const c=i;s.startsWith(`${c}:`)&&(n[c]=Ae(s,c))})}),Object.keys(n).forEach(s=>{const i=n[s];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${s}`,{cause:i})}),n},Ue=async()=>{const{GNUPGHOME:e,HOME:t,USERPROFILE:r}=w.env;if(typeof e=="string"&&e!=="")return e;if(typeof t=="string"&&t!=="")return P.join(t,M);if(typeof r=="string"&&r!==""&&C.platform()===fe.WIN32)return P.join(r,M);const{homedir:n}=await F();return n},Oe=async()=>{const e=await Ue();if(e.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:e});return y.existsSync(e)||y.mkdirSync(e,{recursive:!0}),e},Ce=(e,t)=>{let r="",n=!1;const s=N(e,!0);for(const i of s){if(i.startsWith("fpr:")&&i.includes(`:${t}:`)){n=!0;continue}if(i.startsWith("grp:")&&n){r=i.replace(/(grp|:)/g,"").trim();break}}return r},Le=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await I(t);return Ce(r,e)},Ke=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdout:r}=await I(t),n=N(r,!0),s=[];return n.forEach(i=>{i.startsWith("grp")&&s.push(i.replace(/(grp|:)/g,"").trim())}),s},O=(e,t)=>e.slice(t.length+1).trim(),Me=async()=>{const e=["--version"],{stdout:t}=await I(e),r=N(t,!0),n={gnupg:"",libgcrypt:""};return r.forEach(s=>{s.startsWith("gpg (GnuPG) ")?n.gnupg=O(s,"gpg (GnuPG)"):s.startsWith("gpg (GnuPG/MacGPG2) ")?n.gnupg=O(s,"gpg (GnuPG/MacGPG2)"):s.startsWith("libgcrypt ")&&(n.libgcrypt=O(s,"libgcrypt"))}),Object.keys(n).forEach(s=>{const i=n[s];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${s}`,{cause:i})}),n},xe=e=>e.trimStart().startsWith("---"),D=e=>xe(e)?e:Buffer.from(e,"base64").toString(),He=async e=>{const t=D(e),r=await te.readKey({armoredKey:t}),{user:n}=await r.getPrimaryUser(),s=r.getFingerprint().toUpperCase(),i=r.getKeyID().toHex().toUpperCase(),c=we(re),{name:l,address:a}=c(n.userID?.userID??"")[0],g=r.getCreationTime();return{digest:s,id:i,name:l,email:a,creationTime:g}},We=async e=>{const t=P.join(C.tmpdir(),`mnrendra-import-gpg-${L.nanoid()}`),r=y.mkdtempSync(t),n=`${r}/${L.nanoid()}.pgp`,s=D(e);y.writeFileSync(n,s,{mode:384});const i=["--import","--batch","--yes",n],{stdout:c,stderr:l}=await I(i);return l!==""?l:(y.unlinkSync(n),y.rmSync(r),c)},je=async()=>{const e=await R("KILLAGENT");console.log("susu----------killAgent:",e)},q=async(e,t)=>{const r=Buffer.from(t,"utf8").toString("hex").toUpperCase(),n=await R(`PRESET_PASSPHRASE ${e} -1 ${r}`);console.log("susu----------presetPassphrase:",n);const s=await R(`KEYINFO ${e}`);return console.log("susu----------keyinfo:",s),s},Fe=async(e,t)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",e],n=Buffer.from(`trust
${t}
y
quit
`);await I(r,{input:n})},V="user.signingkey",B="user.name",Y="user.email",z="commit.gpgsign",X="tag.gpgsign",J="push.gpgsign",De=async(e,t,r,{scope:n,signUser:s,signCommit:i,signTag:c,signPush:l})=>{o("---------------- Configuring Git ---------------------------------");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""},g=n==="global";return a.scope=n,o(`scope           : ${a.scope}`),s&&(await E(V,e,g),a.userSigningkey=await S(V,g),o(`user.signingkey : ${a.userSigningkey}`),await E(B,t,g),a.userName=await S(B,g),o(`user.name       : ${a.userName}`),await E(Y,r,g),a.userEmail=await S(Y,g),o(`user.email      : ${a.userEmail}`)),i&&(await E(z,`${i}`,g),a.commitGpgsign=await S(z,g),o(`commit.gpgsign  : ${a.commitGpgsign}`)),c&&(await E(X,`${c}`,g),a.tagGpgsign=await S(X,g),o(`tag.gpgsign     : ${a.tagGpgsign}`)),l!==!1&&(await E(J,`${l}`,g),a.pushGpgsign=await S(J,g),o(`push.gpgsign    : ${a.pushGpgsign}`)),a},qe=async(e,t,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const s=await Oe();if(await ke(s,Ge),n.gpgHome=s,o("---------------- Configuring GnuPG agent -------------------------"),o(`GnuPG home      : ${s}`),t!==void 0){o("---------------- Getting keygrip for fingerprint -----------------");const i=await Le(t);o(`Presetting passphrase for key ${t} with keygrip ${i}`);const c=await q(i,r);A(c),n.keygrips=[i]}else{o("---------------- Getting keygrips --------------------------------");const i=await Ke(e);for(const c of i){o(`Presetting passphrase for ${c}`);const l=await q(c,r);A(l)}n.keygrips=i}return n},Ve=async()=>{const e=await Me(),t=await F(),r={...e,...t};Object.keys(r).forEach(s=>{const i=r[s];if(typeof i!="string"&&i==="")throw new Error(`Invalid GPG ${s} value`,{cause:i})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return o("---------------- GnuPG info --------------------------------------"),o(`Version         : ${n}`),o(`Libdir          : ${r.libdir}`),o(`Libexecdir      : ${r.libexecdir}`),o(`Datadir         : ${r.datadir}`),o(`Homedir         : ${r.homedir}`),{...r,version:n}},Be=async e=>{const{digest:t,id:r,name:n,email:s,creationTime:i}=await He(e);return o("---------------- GPG private key info ----------------------------"),o(`Fingerprint     : ${t}`),o(`KeyID           : ${r}`),o(`Name            : ${n}`),o(`Email           : ${s}`),o(`CreationTime    : ${i.toUTCString()}`),{digest:t,id:r,name:n,email:s,creationTime:i}},Ye=async(e,t)=>{o("---------------- Importing GPG private key -----------------------");const r=await We(e);return o(r),r},ze=(e,t)=>{o("---------------- Fingerprint to use ------------------------------"),o(t??e)},Xe=async(e,t)=>{if(t===void 0)return"";const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:t});return o("---------------- Setting key's trust level ----------------------"),await Fe(e,t),o(`Trust level set to ${t} for ${e}`),`Trust level set to ${t} for ${e}`},Je=async e=>{const t=w.cwd();x({...m,cwd:t});const r=P.resolve(e);t!==r&&(o("---------------- Change working directory ------------------------"),w.chdir(r),o(`Using ${r} as working directory...`))},Qe=async(e,t={})=>{try{if(typeof e!="string"||e==="")throw new Error("Invalid GnuPG private key",{cause:e});const r=be(t),{workdir:n,fingerprint:s,passphrase:i,trustLevel:c}=r;await Je(n);const l=await Ve(),a=await Be(e),{digest:g,id:p,name:$,email:h}=a;ze(g,s);const v=await Ye(e),T=await qe(g,s,i);await Xe(p,c),U("---------------- Successfully set up GPG key ---------------------");const _={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},f=await De(p,$,h,_);U("---------------- Successfully configured Git ---------------------");const Q={...l,...a,...T,...f,keyid:p,fingerprint:s??g,log:v,trustLevel:c,gitConfigScope:f.scope,gitUserSigningkey:f.userSigningkey,gitUserName:f.userName,gitUserEmail:f.userEmail,gitCommitGpgsign:f.commitGpgsign,gitTagGpgsign:f.tagGpgsign,gitPushGpgsign:f.pushGpgsign,workdir:w.cwd()};return W(),Q}catch(r){throw W(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},Ze=async(e="")=>{if(e.length<=0){A("Primary key fingerprint is not defined. Skipping cleanup.");return}try{o("---------------- Cleaning up GPG key -----------------------------"),o(`Removing key ${e}`),await Ne(e),o("Killing GnuPG agent"),await je(),U("---------------- Successfully cleaned up GPG key -----------------")}catch(t){const r=t instanceof Error?t.message:"Unknown error";j(r),j(`${t}`)}},d=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:w.env.GITHUB_TOKEN}),u=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),et=()=>{const e=G.getInput(u.GPG_FINGERPRINT);if(e===void 0||e==="")return d.GPG_FINGERPRINT;if(typeof e!="string")throw new Error(`Invalid ${u.GPG_FINGERPRINT} input`,{cause:e});return e},tt=()=>{const e=G.getInput(u.GIT_SCOPE);if(e===void 0||e==="")return d.GIT_SCOPE;if(typeof e!="string"||!["global","local"].includes(e))throw new Error(`Invalid ${u.GIT_SCOPE} input`,{cause:e});return e},rt=()=>{const e=G.getInput(u.GIT_SIGN_COMMIT);if(e===void 0||e==="")return d.GIT_SIGN_COMMIT;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${u.GIT_SIGN_COMMIT} input`,{cause:e})}},nt=()=>{const e=G.getInput(u.GIT_SIGN_PUSH);if(e===void 0||e==="")return d.GIT_SIGN_PUSH;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${u.GIT_SIGN_PUSH} input`,{cause:e})}},st=()=>{const e=G.getInput(u.GIT_SIGN_TAG);if(e===void 0||e==="")return d.GIT_SIGN_TAG;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${u.GIT_SIGN_TAG} input`,{cause:e})}},it=()=>{const e=G.getInput(u.GIT_SIGN_USER);if(e===void 0||e==="")return d.GIT_SIGN_USER;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${u.GIT_SIGN_USER} input`,{cause:e})}},ot=()=>{const e=G.getInput(u.GPG_PASSPHRASE);if(e===void 0||e==="")return d.GPG_PASSPHRASE;if(typeof e!="string")throw new Error(`Invalid ${u.GPG_PASSPHRASE} input`,{cause:e});return e},at=()=>{const e=G.getInput(u.GPG_PRIVATE_KEY);if(e===void 0||e==="")return d.GPG_PRIVATE_KEY;if(typeof e!="string")throw new Error(`Invalid ${u.GPG_PRIVATE_KEY} input`,{cause:e});return e},ct=()=>{const e=G.getInput(u.TOKEN);if(e===void 0||e==="")return d.TOKEN;if(typeof e!="string")throw new Error(`Invalid ${u.TOKEN} input`,{cause:e});return e},gt=()=>{const e=G.getInput(u.GPG_TRUST_LEVEL);if(e===void 0||e==="")return d.GPG_TRUST_LEVEL;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error(`Invalid ${u.GPG_TRUST_LEVEL} input`,{cause:e});return t},ut=()=>{const e=G.getInput(u.WORKDIR);if(e===void 0||e==="")return d.WORKDIR;if(typeof e!="string")throw new Error(`Invalid ${u.WORKDIR} input`,{cause:e});return e},lt=()=>{const e=et(),t=tt(),r=rt(),n=nt(),s=st(),i=it(),c=ot(),l=at(),a=ct(),g=gt(),p=ut();return{fingerprint:e,gitScope:t,gitSignCommit:r,gitSignPush:n,gitSignTag:s,gitSignUser:i,passphrase:c,privateKey:l,token:a,trustLevel:g,workdir:p}},pt=e=>{if(typeof e=="function")return e;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&typeof e.default=="function")return e.default;throw new Error("Invalid module")},ft=async()=>{await b.execa("git",["config","--global","--add","safe.directory",ne]);const{workdir:e,privateKey:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:c,gitSignCommit:l,gitSignTag:a,gitSignPush:g,token:p}=lt();let $="",h="GitOps Release",v="gitops-release@users.noreply.github.com",T=w.cwd();if(t!==void 0){const f=await Qe(t,{workdir:e,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:c,gitSignCommit:l,gitSignTag:a,gitSignPush:g,verbose:!0});$=f.digest,h=f.name,v=f.email,T=f.workdir}const _=await pt(Z)(le,{env:{...w.env,GIT_AUTHOR_NAME:h,GIT_AUTHOR_EMAIL:v,GIT_COMMITTER_NAME:h,GIT_COMMITTER_EMAIL:v,GITHUB_TOKEN:p}});return _!==!1?console.log("release:",_.nextRelease.version):console.warn("failed to release!"),await Ze($),T};ft().then(e=>{console.log("hasil:",e)}).catch(e=>{throw e instanceof Error?e:new Error("Unknown error")});

#!/usr/bin/env node
"use strict";var G=require("node:process"),pe=require("semantic-release"),A=require("execa"),m=require("node:fs"),E=require("node:path"),C=require("node:os"),L=require("nanoid"),fe=require("openpgp"),Ge=require("addressparser"),l=require("@actions/core");const de="/github/workspace",K=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)&&"__esModule"in e&&e.__esModule===!0&&"default"in e?e.default:e,d=async(e,r=[])=>await A.execa("git",[e,...r]),we=(e,{force:r=!1}={})=>{const t=[];return r&&t.push("-f"),[...t,"--",e]},ye=async(e,r={})=>{const t=we(e,r);return await d("add",t)},me=(e,{allowEmpty:r=!1,keyid:t,sign:n=!1}={})=>{const s=[];if(n){const i="-S",o=typeof t=="string"&&t!==""?`${i}${t}`:i;s.push(o)}return r&&s.push("--allow-empty"),[...s,"-m",`${e}`]},$e=async(e,r={})=>{const t=me(e,r);return await d("commit",t)},he=(e,{get:r=!1,list:t=!1,unset:n=!1,scope:s="local",value:i}={})=>{const o=[`--${s}`];return i!=null?o.push(`${e}`,`${i.toString()}`):r?o.push("--get",`${e}`):n?o.push("--unset",`${e}`):t&&o.push("--list"),o},P=async(e,r)=>{const t=he(e,r);return await d("config",t)},$=async(e,r="local")=>{const{stdout:t}=await P(e,{get:!0,scope:r});if(t==="false")return!1;if(t==="true")return!0;const n=Number(t);return Number.isNaN(n)?t:n},h=async(e,r,t="local")=>await P(e,{scope:t,value:r}),Ie=(e,{tags:r=!1}={})=>{const t=[];let n="";return r===!0&&t.push("--tags"),typeof r=="string"&&(n=r),[...t,e,n]},Ee=async(e,r={})=>{const t=Ie(e,r);return await d("ls-remote",t)},ve=(e,{delete:r=!1,force:t=!1,remote:n="origin",signed:s=!1}={})=>{const i=[n,e];return r?[n,"-d",e]:(t&&i.push("-f"),s!==!1&&i.push(`--signed=${s}`),i)},Se=async(e,r={})=>{const t=ve(e,r);return await d("push",t)},Pe=(e,{quiet:r=!1}={})=>{const t=[];return r&&t.push("-q"),[...t,"--",e]},Te=async(e,r={})=>{const t=Pe(e,r);return await d("reset",t)},_e=(e,{cached:r=!1,force:t=!1,ignoreUnmatch:n=!1,quiet:s=!1,recursive:i=!1}={})=>{const o=[];return t&&o.push("-f"),r&&o.push("--cached"),n&&o.push("--ignore-unmatch"),s&&o.push("-q"),i&&o.push("-r"),[...o,"--",e]},Ne=async(e,r={})=>{const t=_e(e,r);return await d("rm",t)},be=(e,{commit:r,delete:t=!1,force:n=!1,list:s=!1,message:i="",sign:o=!1}={})=>{if(t)return["-d",e];if(s)return e===""?["-l"]:["-l",e];const u=[];return n&&u.push("-f"),o&&u.push("-s"),u.push(e),r!==void 0&&u.push(r),[...u,"-m",`${i}`]},ke=async(e,r={})=>{const t=be(e,r);return await d("tag",t)},Re=e=>({value:e,enumerable:!0,configurable:!1,writable:!1}),Oe=(e,r)=>{Object.keys(r).forEach(t=>{const n=Re(r[t]);Object.defineProperty(e,t,n)})};Oe(d,{add:ye,commit:$e,config:P,getConfig:$,setConfig:h,lsRemote:Ee,push:Se,reset:Te,rm:Ne,tag:ke});const T=e=>`\x1B[${e}m`,Ue=T(32),Ae=T(33),Ce=T(90),_=(e,r,t="\x1B[39m")=>e.split(`
`).map(n=>(n=r+n,n=n.endsWith("\r")?n.slice(0,-1)+t+"\r":n+t,n)).join(`
`),M=e=>{console.log(_(e,Ae))},N=e=>{console.log(_(e,Ue))},b=e=>{console.log(_(e,Ce))},a=e=>{console.log(e)},Le="gpg-agent.conf",H=".gnupg",Ke={WIN32:"win32"},x=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,F=(e,r=!1)=>e.split(/\n\r|\r\n|\r|\n/).map(t=>r?t.trim():t),k=async(e,r=[],t={})=>{const n=await A.execa(e,r,t),s=F(n.stderr,!0),i=F(n.stdout,!0);return{...n,stderrLines:s,stdoutLines:i}},Me=e=>{try{return m.statSync(e).isDirectory()}catch{return!1}},v=async e=>{const{stdout:r}=await k("gpg-connect-agent",[e,"/bye"]);return r},W=async(e,r)=>{const t=E.join(e,Le);m.writeFileSync(t,r),await v("RELOADAGENT")},I=async(e=[],r={})=>await k("gpg",e,r),He=async e=>{const r=["--batch","--yes",e],t=n=>[...r.slice(0,2),n,...r.slice(-1)];await I(t("--delete-secret-keys")),await I(t("--delete-keys"))},xe=async(e=[])=>await k("gpgconf",e),Fe=(e,r)=>e.slice(r.length+1).replace("%3a",":").trim(),R=async()=>{const e=["--list-dirs"],{stdoutLines:r}=await xe(e),t={libdir:"",libexecdir:"",datadir:"",homedir:""};return r.forEach(n=>{Object.keys(t).forEach(s=>{const i=s;n.startsWith(`${i}:`)&&(t[i]=Fe(n,i))})}),Object.keys(t).forEach(n=>{const s=t[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),t},We=async()=>{const{GNUPGHOME:e,HOME:r,USERPROFILE:t}=G.env;if(typeof e=="string"&&e!=="")return e;if(typeof r=="string"&&r!=="")return E.join(r,H);if(typeof t=="string"&&t!==""&&C.platform()===Ke.WIN32)return E.join(t,H);const{homedir:n}=await R();return n},j=async()=>{const e=await We();if(e.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:e});return m.existsSync(e)||m.mkdirSync(e,{recursive:!0}),e},q=(e,r)=>{let t="",n=!1;for(const s of e){if(s.startsWith("fpr:")&&s.includes(`:${r}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){t=s.replace(/(grp|:)/g,"").trim();break}}return t},D=async e=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdoutLines:t}=await I(r);return q(t,e)},V=async e=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdoutLines:t}=await I(r),n=[];return t.forEach(s=>{s.startsWith("grp")&&n.push(s.replace(/(grp|:)/g,"").trim())}),n},O=(e,r)=>e.slice(r.length+1).trim(),B=async()=>{const e=["--version"],{stdoutLines:r}=await I(e),t={gnupg:"",libgcrypt:""};return r.forEach(n=>{n.startsWith("gpg (GnuPG) ")?t.gnupg=O(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?t.gnupg=O(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(t.libgcrypt=O(n,"libgcrypt"))}),Object.keys(t).forEach(n=>{const s=t[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),t},je=e=>e.trimStart().startsWith("---"),Y=e=>je(e)?e:Buffer.from(e,"base64").toString(),qe=async e=>{const r=Y(e),t=await fe.readKey({armoredKey:r}),{user:n}=await t.getPrimaryUser(),s=t.getFingerprint().toUpperCase(),i=t.getKeyID().toHex().toUpperCase(),o=K(Ge),{name:u,address:c}=o(n.userID?.userID??"")[0],f=t.getCreationTime();return{digest:s,id:i,name:u,email:c,creationTime:f}},z=async e=>{const r=E.join(C.tmpdir(),`mnrendra-import-gpg-${L.nanoid()}`),t=m.mkdtempSync(r),n=`${t}/${L.nanoid()}.pgp`,s=Y(e);m.writeFileSync(n,s,{mode:384});const i=["--import","--batch","--yes",n],{stdout:o,stderr:u}=await I(i);return u!==""?u:(m.unlinkSync(n),m.rmSync(t),o)},De=async()=>{await v("KILLAGENT")},U=async(e,r)=>{const t=Buffer.from(r,"utf8").toString("hex").toUpperCase();return await v(`PRESET_PASSPHRASE ${e} -1 ${t}`),await v(`KEYINFO ${e}`)},X=async(e,r)=>{const t=["--batch","--no-tty","--command-fd","0","--edit-key",e],n=Buffer.from(`trust
${r}
y
quit
`);await I(t,{input:n})};var J={GPG_AGENT_CONF:x,configureAgent:W,deleteKey:He,getDirs:R,getHome:j,getKeygrip:D,getKeygrips:V,getVersion:B,importKey:z,killAgent:De,parseKeygripFromGpgColonsOutput:q,presetPassphrase:U,setTrust:X};const Q="user.signingkey",Z="user.name",ee="user.email",te="commit.gpgsign",re="tag.gpgsign",ne="push.gpgsign",Ve=async(e,r,t,{scope:n,signUser:s,signCommit:i,signTag:o,signPush:u})=>{a("---------------- Configuring Git ---------------------------------");const c={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""};return c.scope=n,a(`scope           : ${c.scope}`),s&&(await h(Q,e,n),c.userSigningkey=await $(Q,n),a(`user.signingkey : ${c.userSigningkey}`),await h(Z,r,n),c.userName=await $(Z,n),a(`user.name       : ${c.userName}`),await h(ee,t,n),c.userEmail=await $(ee,n),a(`user.email      : ${c.userEmail}`)),i&&(await h(te,i,n),c.commitGpgsign=await $(te,n),a(`commit.gpgsign  : ${c.commitGpgsign}`)),o&&(await h(re,o,n),c.tagGpgsign=await $(re,n),a(`tag.gpgsign     : ${c.tagGpgsign}`)),u!==!1&&(await h(ne,u,n),c.pushGpgsign=await $(ne,n),a(`push.gpgsign    : ${c.pushGpgsign}`)),c},Be=async(e,r,t)=>{const n={gpgHome:"",keygrips:[]};if(t===void 0)return n;const s=await j();if(await W(s,x),n.gpgHome=s,a("---------------- Configuring GnuPG agent -------------------------"),a(`GnuPG home      : ${s}`),r!==void 0){a("---------------- Getting keygrip for fingerprint -----------------");const i=await D(r);a(`Presetting passphrase for key ${r} with keygrip ${i}`);const o=await U(i,t);b(o),n.keygrips=[i]}else{a("---------------- Getting keygrips --------------------------------");const i=await V(e);for(const o of i){a(`Presetting passphrase for ${o}`);const u=await U(o,t);b(u)}n.keygrips=i}return n},Ye=async()=>{const e=await B(),r=await R(),t={...e,...r};Object.keys(t).forEach(s=>{const i=t[s];if(typeof i!="string"&&i==="")throw new Error(`Invalid GPG ${s} value`,{cause:i})});const n=`${t.gnupg} (libgcrypt ${t.libgcrypt})`;return a("---------------- GnuPG info --------------------------------------"),a(`Version         : ${n}`),a(`Libdir          : ${t.libdir}`),a(`Libexecdir      : ${t.libexecdir}`),a(`Datadir         : ${t.datadir}`),a(`Homedir         : ${t.homedir}`),{...t,version:n}},ze=async e=>{const{digest:r,id:t,name:n,email:s,creationTime:i}=await qe(e);return a("---------------- GPG private key info ----------------------------"),a(`Fingerprint     : ${r}`),a(`KeyID           : ${t}`),a(`Name            : ${n}`),a(`Email           : ${s}`),a(`CreationTime    : ${i.toUTCString()}`),{digest:r,id:t,name:n,email:s,creationTime:i}},Xe=async(e,r)=>{a("---------------- Importing GPG private key -----------------------");const t=await z(e);return a(t),t},Je=(e,r)=>{a("---------------- Fingerprint to use ------------------------------"),a(r??e)},S={cwd:G.cwd(),verbose:!1},se=e=>{Object.keys(e).forEach(r=>{S[r]=e[r]})},ie=()=>{const e=G.cwd(),r=S.cwd;e!==r&&(a("---------------- Restore working directory -----------------------"),G.chdir(r),a(`Restore working directory to ${r}.`))},Qe=async(e,r)=>{if(r===void 0)return"";const t=Number(r);if(Number.isNaN(t)||t<1||t>5)throw new Error("Invalid GPG Trust Level value",{cause:r});return a("---------------- Setting key's trust level ----------------------"),await X(e,r),a(`Trust level set to ${r} for ${e}`),`Trust level set to ${r} for ${e}`},Ze=async e=>{const r=G.cwd();se({...S,cwd:r});const t=E.resolve(e);r!==t&&(a("---------------- Change working directory ------------------------"),G.chdir(t),a(`Using ${t} as working directory...`))},et=(e=".")=>{if(typeof e!="string"||e==="")throw new Error("Invalid workdir value",{cause:e});if(!Me(e))throw new Error(`workdir ${e} is doesn't exist`,{cause:e});return e},tt=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid passphrase value",{cause:e});return e}},rt=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid fingerprint value",{cause:e});return e}},nt=e=>{if(e===void 0)return;const r=Number(e);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid trustLevel value",{cause:e});return e},st=(e="local")=>{if(typeof e!="string"||!["global","local"].includes(e))throw new Error("Invalid gitScope value",{cause:e});return e},it=(e=!0)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignUser value",{cause:e});return e},at=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignCommit value",{cause:e});return e},ot=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignTag value",{cause:e});return e},ct=(e=!1)=>{if(typeof e!="boolean"&&(typeof e!="string"||e!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:e});return e},ut=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid verbose value",{cause:e});return e},gt=e=>{if(typeof e!="object"||e===null||Array.isArray(e))throw new Error("Invalid options value",{cause:e});const r=et(e.workdir),t=tt(e.passphrase),n=rt(e.fingerprint),s=nt(e.trustLevel),i=st(e.gitScope),o=it(e.gitSignUser),u=at(e.gitSignCommit),c=ot(e.gitSignTag),f=ct(e.gitSignPush),w=ut(e.verbose);return se({...S,verbose:w}),a("---------------- importGPG's options to use ---------------------"),a(`workdir         : ${r}`),a(`passphrase      : ${t}`),a(`fingerprint     : ${n}`),a(`trustLevel      : ${s}`),a(`gitScope        : ${i}`),a(`gitSignUser     : ${o}`),a(`gitSignCommit   : ${u}`),a(`gitSignTag      : ${c}`),a(`gitSignPush     : ${f}`),a(`verbose         : ${w}`),{workdir:r,passphrase:t,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:o,gitSignCommit:u,gitSignTag:c,gitSignPush:f,verbose:w}},lt=async(e,r={})=>{try{if(typeof e!="string"||e==="")throw new Error("Invalid GnuPG private key",{cause:e});const t=gt(r),{workdir:n,fingerprint:s,passphrase:i,trustLevel:o}=t;await Ze(n);const u=await Ye(),c=await ze(e),{digest:f,id:w,name:ae,email:oe}=c;Je(f,s);const ce=await Xe(e),ue=await Be(f,s,i);await Qe(w,o),N("---------------- Successfully set up GPG key ---------------------");const ge={scope:t.gitScope,signUser:t.gitSignUser,signCommit:t.gitSignCommit,signTag:t.gitSignTag,signPush:t.gitSignPush},y=await Ve(w,ae,oe,ge);N("---------------- Successfully configured Git ---------------------");const le={...u,...c,...ue,...y,keyid:w,fingerprint:s??f,log:ce,trustLevel:o,gitConfigScope:y.scope,gitUserSigningkey:y.userSigningkey,gitUserName:y.userName,gitUserEmail:y.userEmail,gitCommitGpgsign:y.commitGpgsign,gitTagGpgsign:y.tagGpgsign,gitPushGpgsign:y.pushGpgsign,workdir:G.cwd()};return ie(),le}catch(t){throw ie(),t instanceof Error?t:new Error("Unknown error",{cause:t})}},pt=async(e="")=>{if(e.length<=0){b("Primary key fingerprint is not defined. Skipping cleanup.");return}try{a("---------------- Cleaning up GPG key -----------------------------"),a(`Removing key ${e}`),await J.deleteKey(e),a("Killing GnuPG agent"),await J.killAgent(),N("---------------- Successfully cleaned up GPG key -----------------")}catch(r){const t=r instanceof Error?r.message:"Unknown error";M(t),M(`${r}`)}},ft=["alpha","beta","rc"],Gt=ft.map(e=>({name:e,prerelease:!0})),dt=["+([0-9])?(.{+([0-9]),x}).x","main","next",...Gt],wt="/action",yt=["docs","style","refactor","perf","test","build","ci","chore","revert"],mt=yt.map(e=>({type:e,release:"patch"})),$t=[["@semantic-release/commit-analyzer",{releaseRules:mt}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],[`${wt}/@mnrendra/semantic-release-plugin-github-action`,{actionFile:"action.yml",ignoreFile:".ghaignore",releaseMessage:`release: v{nextRelease.version}

{nextRelease.notes}`,latestMessage:`latest: v{nextRelease.version}

{nextRelease.notes}`,sign:!0}],"@semantic-release/github"],ht={branches:dt,plugins:$t,dryRun:!1,ci:!0},p=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:G.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),It=()=>{const e=l.getInput(g.GPG_FINGERPRINT);if(e===void 0||e==="")return p.GPG_FINGERPRINT;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:e});return e},Et=()=>{const e=l.getInput(g.GIT_SCOPE);if(e===void 0||e==="")return p.GIT_SCOPE;if(typeof e!="string"||!["global","local"].includes(e))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:e});return e},vt=()=>{const e=l.getInput(g.GIT_SIGN_COMMIT);if(e===void 0||e==="")return p.GIT_SIGN_COMMIT;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:e})}},St=()=>{const e=l.getInput(g.GIT_SIGN_PUSH);if(e===void 0||e==="")return p.GIT_SIGN_PUSH;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:e})}},Pt=()=>{const e=l.getInput(g.GIT_SIGN_TAG);if(e===void 0||e==="")return p.GIT_SIGN_TAG;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:e})}},Tt=()=>{const e=l.getInput(g.GIT_SIGN_USER);if(e===void 0||e==="")return p.GIT_SIGN_USER;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:e})}},_t=()=>{const e=l.getInput(g.GPG_PASSPHRASE);if(e===void 0||e==="")return p.GPG_PASSPHRASE;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:e});return e},Nt=()=>{const e=l.getInput(g.GPG_PRIVATE_KEY);if(e===void 0||e==="")return p.GPG_PRIVATE_KEY;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:e});return e},bt=()=>{const e=l.getInput(g.TOKEN);if(e===void 0||e==="")return p.TOKEN;if(typeof e!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:e});return e},kt=()=>{const e=l.getInput(g.GPG_TRUST_LEVEL);if(e===void 0||e==="")return p.GPG_TRUST_LEVEL;const r=Number(e);if(Number.isNaN(r)||r<1||r>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:e});return r},Rt=()=>{const e=l.getInput(g.WORKDIR);if(e===void 0||e==="")return p.WORKDIR;if(typeof e!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:e});return e},Ot=()=>{const e=It(),r=Et(),t=vt(),n=St(),s=Pt(),i=Tt(),o=_t(),u=Nt(),c=bt(),f=kt(),w=Rt();return{fingerprint:e,gitScope:r,gitSignCommit:t,gitSignPush:n,gitSignTag:s,gitSignUser:i,passphrase:o,privateKey:u,token:c,trustLevel:f,workdir:w}},Ut=async()=>{await d.setConfig("safe.directory",de,"global");const e=Ot();let r="",t="GitOps Release",n="gitops-release@users.noreply.github.com",s=G.cwd();const{privateKey:i,token:o}=e;if(i!==void 0){const c=await lt(i,{...e,verbose:!0});r=c.digest,t=c.name,n=c.email,s=c.workdir}const u=await K(pe)(ht,{env:{...G.env,GIT_AUTHOR_NAME:t,GIT_AUTHOR_EMAIL:n,GIT_COMMITTER_NAME:t,GIT_COMMITTER_EMAIL:n,GITHUB_TOKEN:o}});return u!==!1?console.log("release:",u.nextRelease.version):console.warn("failed to release!"),await pt(r),s};Ut().then(e=>{console.log("hasil:",e)}).catch(e=>{throw e instanceof Error?e:new Error("Unknown error")});

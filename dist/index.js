#!/usr/bin/env node
"use strict";var G=require("node:process"),rt=require("semantic-release"),O=require("execa"),y=require("node:fs"),E=require("node:path"),U=require("node:os"),C=require("nanoid"),nt=require("openpgp"),st=require("addressparser"),l=require("@actions/core");const it="/github/workspace",A=t=>typeof t=="object"&&t!==null&&!Array.isArray(t)&&"__esModule"in t&&t.__esModule===!0&&"default"in t?t.default:t,I=async(t,r=[])=>await O.execa("git",[t,...r]),ot=(t,{allowEmpty:r=!1,keyid:e,sign:n=!1}={})=>{const s=[];if(n){const o="-S",c=typeof e=="string"&&e!==""?`${o}${e}`:o;s.push(c)}return r&&s.push("--allow-empty"),[...s,"-m",`${t}`]},at=async(t,r={})=>{const e=ot(t,r);return await I("commit",e)},ct=(t,{get:r=!1,list:e=!1,unset:n=!1,scope:s="local",value:o}={})=>{const c=[`--${s}`];return o!=null?c.push(`${t}`,`${o.toString()}`):r?c.push("--get",`${t}`):n?c.push("--unset",`${t}`):e&&c.push("--list"),c},P=async(t,r)=>{const e=ct(t,r);return await I("config",e)},m=async(t,r="local")=>{const{stdout:e}=await P(t,{get:!0,scope:r});if(e==="false")return!1;if(e==="true")return!0;const n=Number(e);return Number.isNaN(n)?e:n},$=async(t,r,e="local")=>await P(t,{scope:e,value:r}),gt=(t,{delete:r=!1,remote:e="origin",signed:n=!1}={})=>{const s=[e,t];return r?[e,"-d",t]:(n!==!1&&s.push(`--signed=${n}`),s)},ut=async(t,r={})=>{const e=gt(t,r);return await I("push",e)},lt=(t,{commit:r,delete:e=!1,message:n="",sign:s=!1}={})=>{if(e)return["-d",t];const o=[];return s&&o.push("-s"),o.push(t),r!==void 0&&o.push(r),[...o,"-m",`${n}`]},pt=async(t,r={})=>{const e=lt(t,r);return await I("tag",e)},ft=t=>({value:t,enumerable:!0,configurable:!1,writable:!1}),Gt=(t,r)=>{Object.keys(r).forEach(e=>{const n=ft(r[e]);Object.defineProperty(t,e,n)})};Gt(I,{commit:at,config:P,getConfig:m,setConfig:$,push:ut,tag:pt});const T=t=>`\x1B[${t}m`,dt=T(32),wt=T(33),yt=T(90),_=(t,r,e="\x1B[39m")=>t.split(`
`).map(n=>(n=r+n,n=n.endsWith("\r")?n.slice(0,-1)+e+"\r":n+e,n)).join(`
`),L=t=>{console.log(_(t,wt))},N=t=>{console.log(_(t,dt))},b=t=>{console.log(_(t,yt))},i=t=>{console.log(t)},mt="gpg-agent.conf",M=".gnupg",$t={WIN32:"win32"},ht=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,K=(t,r=!1)=>t.split(/\n\r|\r\n|\r|\n/).map(e=>r?e.trim():e),k=async(t,r=[],e={})=>{const n=await O.execa(t,r,e),s=K(n.stderr,!0),o=K(n.stdout,!0);return{...n,stderrLines:s,stdoutLines:o}},It=t=>{try{return y.statSync(t).isDirectory()}catch{return!1}},S=async t=>{const{stdout:r}=await k("gpg-connect-agent",[t,"/bye"]);return r},Et=async(t,r)=>{const e=E.join(t,mt);y.writeFileSync(e,r),await S("RELOADAGENT")},h=async(t=[],r={})=>await k("gpg",t,r),St=async t=>{const r=["--batch","--yes",t],e=n=>[...r.slice(0,2),n,...r.slice(-1)];await h(e("--delete-secret-keys")),await h(e("--delete-keys"))},vt=async(t=[])=>await k("gpgconf",t),Pt=(t,r)=>t.slice(r.length+1).replace("%3a",":").trim(),H=async()=>{const t=["--list-dirs"],{stdoutLines:r}=await vt(t),e={libdir:"",libexecdir:"",datadir:"",homedir:""};return r.forEach(n=>{Object.keys(e).forEach(s=>{const o=s;n.startsWith(`${o}:`)&&(e[o]=Pt(n,o))})}),Object.keys(e).forEach(n=>{const s=e[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),e},Tt=async()=>{const{GNUPGHOME:t,HOME:r,USERPROFILE:e}=G.env;if(typeof t=="string"&&t!=="")return t;if(typeof r=="string"&&r!=="")return E.join(r,M);if(typeof e=="string"&&e!==""&&U.platform()===$t.WIN32)return E.join(e,M);const{homedir:n}=await H();return n},_t=async()=>{const t=await Tt();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return y.existsSync(t)||y.mkdirSync(t,{recursive:!0}),t},Nt=(t,r)=>{let e="",n=!1;for(const s of t){if(s.startsWith("fpr:")&&s.includes(`:${r}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){e=s.replace(/(grp|:)/g,"").trim();break}}return e},bt=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:e}=await h(r);return Nt(e,t)},kt=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:e}=await h(r),n=[];return e.forEach(s=>{s.startsWith("grp")&&n.push(s.replace(/(grp|:)/g,"").trim())}),n},R=(t,r)=>t.slice(r.length+1).trim(),Rt=async()=>{const t=["--version"],{stdoutLines:r}=await h(t),e={gnupg:"",libgcrypt:""};return r.forEach(n=>{n.startsWith("gpg (GnuPG) ")?e.gnupg=R(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?e.gnupg=R(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(e.libgcrypt=R(n,"libgcrypt"))}),Object.keys(e).forEach(n=>{const s=e[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),e},Ot=t=>t.trimStart().startsWith("---"),x=t=>Ot(t)?t:Buffer.from(t,"base64").toString(),Ut=async t=>{const r=x(t),e=await nt.readKey({armoredKey:r}),{user:n}=await e.getPrimaryUser(),s=e.getFingerprint().toUpperCase(),o=e.getKeyID().toHex().toUpperCase(),c=A(st),{name:u,address:a}=c(n.userID?.userID??"")[0],f=e.getCreationTime();return{digest:s,id:o,name:u,email:a,creationTime:f}},Ct=async t=>{const r=E.join(U.tmpdir(),`mnrendra-import-gpg-${C.nanoid()}`),e=y.mkdtempSync(r),n=`${e}/${C.nanoid()}.pgp`,s=x(t);y.writeFileSync(n,s,{mode:384});const o=["--import","--batch","--yes",n],{stdout:c,stderr:u}=await h(o);return u!==""?u:(y.unlinkSync(n),y.rmSync(e),c)},At=async()=>{await S("KILLAGENT")},W=async(t,r)=>{const e=Buffer.from(r,"utf8").toString("hex").toUpperCase();return await S(`PRESET_PASSPHRASE ${t} -1 ${e}`),await S(`KEYINFO ${t}`)},Lt=async(t,r)=>{const e=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${r}
y
quit
`);await h(e,{input:n})},j="user.signingkey",F="user.name",D="user.email",q="commit.gpgsign",V="tag.gpgsign",B="push.gpgsign",Mt=async(t,r,e,{scope:n,signUser:s,signCommit:o,signTag:c,signPush:u})=>{i("---------------- Configuring Git ---------------------------------");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""};return a.scope=n,i(`scope           : ${a.scope}`),s&&(await $(j,t,n),a.userSigningkey=await m(j,n),i(`user.signingkey : ${a.userSigningkey}`),await $(F,r,n),a.userName=await m(F,n),i(`user.name       : ${a.userName}`),await $(D,e,n),a.userEmail=await m(D,n),i(`user.email      : ${a.userEmail}`)),o&&(await $(q,o,n),a.commitGpgsign=await m(q,n),i(`commit.gpgsign  : ${a.commitGpgsign}`)),c&&(await $(V,c,n),a.tagGpgsign=await m(V,n),i(`tag.gpgsign     : ${a.tagGpgsign}`)),u!==!1&&(await $(B,u,n),a.pushGpgsign=await m(B,n),i(`push.gpgsign    : ${a.pushGpgsign}`)),a},Kt=async(t,r,e)=>{const n={gpgHome:"",keygrips:[]};if(e===void 0)return n;const s=await _t();if(await Et(s,ht),n.gpgHome=s,i("---------------- Configuring GnuPG agent -------------------------"),i(`GnuPG home      : ${s}`),r!==void 0){i("---------------- Getting keygrip for fingerprint -----------------");const o=await bt(r);i(`Presetting passphrase for key ${r} with keygrip ${o}`);const c=await W(o,e);b(c),n.keygrips=[o]}else{i("---------------- Getting keygrips --------------------------------");const o=await kt(t);for(const c of o){i(`Presetting passphrase for ${c}`);const u=await W(c,e);b(u)}n.keygrips=o}return n},Ht=async()=>{const t=await Rt(),r=await H(),e={...t,...r};Object.keys(e).forEach(s=>{const o=e[s];if(typeof o!="string"&&o==="")throw new Error(`Invalid GPG ${s} value`,{cause:o})});const n=`${e.gnupg} (libgcrypt ${e.libgcrypt})`;return i("---------------- GnuPG info --------------------------------------"),i(`Version         : ${n}`),i(`Libdir          : ${e.libdir}`),i(`Libexecdir      : ${e.libexecdir}`),i(`Datadir         : ${e.datadir}`),i(`Homedir         : ${e.homedir}`),{...e,version:n}},xt=async t=>{const{digest:r,id:e,name:n,email:s,creationTime:o}=await Ut(t);return i("---------------- GPG private key info ----------------------------"),i(`Fingerprint     : ${r}`),i(`KeyID           : ${e}`),i(`Name            : ${n}`),i(`Email           : ${s}`),i(`CreationTime    : ${o.toUTCString()}`),{digest:r,id:e,name:n,email:s,creationTime:o}},Wt=async(t,r)=>{i("---------------- Importing GPG private key -----------------------");const e=await Ct(t);return i(e),e},jt=(t,r)=>{i("---------------- Fingerprint to use ------------------------------"),i(r??t)},v={cwd:G.cwd(),verbose:!1},Y=t=>{Object.keys(t).forEach(r=>{v[r]=t[r]})},z=()=>{const t=G.cwd(),r=v.cwd;t!==r&&(i("---------------- Restore working directory -----------------------"),G.chdir(r),i(`Restore working directory to ${r}.`))},Ft=async(t,r)=>{if(r===void 0)return"";const e=Number(r);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid GPG Trust Level value",{cause:r});return i("---------------- Setting key's trust level ----------------------"),await Lt(t,r),i(`Trust level set to ${r} for ${t}`),`Trust level set to ${r} for ${t}`},Dt=async t=>{const r=G.cwd();Y({...v,cwd:r});const e=E.resolve(t);r!==e&&(i("---------------- Change working directory ------------------------"),G.chdir(e),i(`Using ${e} as working directory...`))},qt=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!It(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},Vt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},Bt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},Yt=t=>{if(t===void 0)return;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid trustLevel value",{cause:t});return t},zt=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},Xt=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},Jt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},Qt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},Zt=(t=!1)=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},te=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},ee=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const r=qt(t.workdir),e=Vt(t.passphrase),n=Bt(t.fingerprint),s=Yt(t.trustLevel),o=zt(t.gitScope),c=Xt(t.gitSignUser),u=Jt(t.gitSignCommit),a=Qt(t.gitSignTag),f=Zt(t.gitSignPush),d=te(t.verbose);return Y({...v,verbose:d}),i("---------------- importGPG's options to use ---------------------"),i(`workdir         : ${r}`),i(`passphrase      : ${e}`),i(`fingerprint     : ${n}`),i(`trustLevel      : ${s}`),i(`gitScope        : ${o}`),i(`gitSignUser     : ${c}`),i(`gitSignCommit   : ${u}`),i(`gitSignTag      : ${a}`),i(`gitSignPush     : ${f}`),i(`verbose         : ${d}`),{workdir:r,passphrase:e,fingerprint:n,trustLevel:s,gitScope:o,gitSignUser:c,gitSignCommit:u,gitSignTag:a,gitSignPush:f,verbose:d}},re=async(t,r={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const e=ee(r),{workdir:n,fingerprint:s,passphrase:o,trustLevel:c}=e;await Dt(n);const u=await Ht(),a=await xt(t),{digest:f,id:d,name:X,email:J}=a;jt(f,s);const Q=await Wt(t),Z=await Kt(f,s,o);await Ft(d,c),N("---------------- Successfully set up GPG key ---------------------");const tt={scope:e.gitScope,signUser:e.gitSignUser,signCommit:e.gitSignCommit,signTag:e.gitSignTag,signPush:e.gitSignPush},w=await Mt(d,X,J,tt);N("---------------- Successfully configured Git ---------------------");const et={...u,...a,...Z,...w,keyid:d,fingerprint:s??f,log:Q,trustLevel:c,gitConfigScope:w.scope,gitUserSigningkey:w.userSigningkey,gitUserName:w.userName,gitUserEmail:w.userEmail,gitCommitGpgsign:w.commitGpgsign,gitTagGpgsign:w.tagGpgsign,gitPushGpgsign:w.pushGpgsign,workdir:G.cwd()};return z(),et}catch(e){throw z(),e instanceof Error?e:new Error("Unknown error",{cause:e})}},ne=async(t="")=>{if(t.length<=0){b("Primary key fingerprint is not defined. Skipping cleanup.");return}try{i("---------------- Cleaning up GPG key -----------------------------"),i(`Removing key ${t}`),await St(t),i("Killing GnuPG agent"),await At(),N("---------------- Successfully cleaned up GPG key -----------------")}catch(r){const e=r instanceof Error?r.message:"Unknown error";L(e),L(`${r}`)}},se=["alpha","beta","rc"],ie=["docs","style","refactor","perf","test","build","ci","chore","revert"],oe=se.map(t=>({name:t,prerelease:!0})),ae=["+([0-9])?(.{+([0-9]),x}).x","main","next",...oe],ce=ie.map(t=>({type:t,release:"patch"})),ge="/action",ue=[["@semantic-release/commit-analyzer",{releaseRules:ce}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${ge}/@mnrendra/semantic-release-plugin-github-action`,"@semantic-release/github"],le={branches:ae,plugins:ue,dryRun:!1,ci:!0},p=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:G.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),pe=()=>{const t=l.getInput(g.GPG_FINGERPRINT);if(t===void 0||t==="")return p.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:t});return t},fe=()=>{const t=l.getInput(g.GIT_SCOPE);if(t===void 0||t==="")return p.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:t});return t},Ge=()=>{const t=l.getInput(g.GIT_SIGN_COMMIT);if(t===void 0||t==="")return p.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:t})}},de=()=>{const t=l.getInput(g.GIT_SIGN_PUSH);if(t===void 0||t==="")return p.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:t})}},we=()=>{const t=l.getInput(g.GIT_SIGN_TAG);if(t===void 0||t==="")return p.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:t})}},ye=()=>{const t=l.getInput(g.GIT_SIGN_USER);if(t===void 0||t==="")return p.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:t})}},me=()=>{const t=l.getInput(g.GPG_PASSPHRASE);if(t===void 0||t==="")return p.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:t});return t},$e=()=>{const t=l.getInput(g.GPG_PRIVATE_KEY);if(t===void 0||t==="")return p.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:t});return t},he=()=>{const t=l.getInput(g.TOKEN);if(t===void 0||t==="")return p.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:t});return t},Ie=()=>{const t=l.getInput(g.GPG_TRUST_LEVEL);if(t===void 0||t==="")return p.GPG_TRUST_LEVEL;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:t});return r},Ee=()=>{const t=l.getInput(g.WORKDIR);if(t===void 0||t==="")return p.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:t});return t},Se=()=>{const t=pe(),r=fe(),e=Ge(),n=de(),s=we(),o=ye(),c=me(),u=$e(),a=he(),f=Ie(),d=Ee();return{fingerprint:t,gitScope:r,gitSignCommit:e,gitSignPush:n,gitSignTag:s,gitSignUser:o,passphrase:c,privateKey:u,token:a,trustLevel:f,workdir:d}},ve=async()=>{await I.setConfig("safe.directory",it);const t=Se();let r="",e="GitOps Release",n="gitops-release@users.noreply.github.com",s=G.cwd();const{privateKey:o,token:c}=t;if(o!==void 0){const a=await re(o,{...t,verbose:!0});r=a.digest,e=a.name,n=a.email,s=a.workdir}const u=await A(rt)(le,{env:{...G.env,GIT_AUTHOR_NAME:e,GIT_AUTHOR_EMAIL:n,GIT_COMMITTER_NAME:e,GIT_COMMITTER_EMAIL:n,GITHUB_TOKEN:c}});return u!==!1?console.log("release:",u.nextRelease.version):console.warn("failed to release!"),await ne(r),s};ve().then(t=>{console.log("hasil:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});

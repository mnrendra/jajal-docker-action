#!/usr/bin/env node
"use strict";var G=require("node:process"),I=require("execa"),et=require("semantic-release"),y=require("node:fs"),E=require("node:path"),U=require("node:os"),C=require("nanoid"),rt=require("openpgp"),nt=require("addressparser"),l=require("@actions/core");const it="/github/workspace",A=t=>typeof t=="object"&&t!==null&&!Array.isArray(t)&&"__esModule"in t&&t.__esModule===!0&&"default"in t?t.default:t,_=t=>`\x1B[${t}m`,st=_(32),ot=_(33),at=_(90),b=(t,e,r="\x1B[39m")=>t.split(`
`).map(n=>(n=e+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),L=t=>{console.log(b(t,ot))},N=t=>{console.log(b(t,st))},k=t=>{console.log(b(t,at))},o=t=>{console.log(t)},ct="gpg-agent.conf",M=".gnupg",gt={WIN32:"win32"},ut=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,v=async t=>{const{stdout:e}=await I.execa("gpg-connect-agent",[t,"/bye"]);return e},lt=async(t,e)=>{const r=E.join(t,ct);y.writeFileSync(r,e),await v("RELOADAGENT")},m=async(t=[],e={})=>await I.execa("gpg",t,e),pt=async t=>{const e=["--batch","--yes",t],r=n=>[...e.slice(0,2),n,...e.slice(-1)];await m(r("--delete-secret-keys")),await m(r("--delete-keys"))},ft=async(t=[])=>await I.execa("gpgconf",t),Gt=t=>{try{return y.statSync(t).isDirectory()}catch{return!1}},P=(t,e=!1)=>t.split(/\n\r|\r\n|\r|\n/).map(r=>e?r.trim():r),dt=(t,e)=>t.slice(e.length+1).replace("%3a",":").trim(),K=async()=>{const t=["--list-dirs"],{stdout:e}=await ft(t),r=P(e,!0),n={libdir:"",libexecdir:"",datadir:"",homedir:""};return r.forEach(i=>{Object.keys(n).forEach(s=>{const a=s;i.startsWith(`${a}:`)&&(n[a]=dt(i,a))})}),Object.keys(n).forEach(i=>{const s=n[i];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${i}`,{cause:s})}),n},wt=async()=>{const{GNUPGHOME:t,HOME:e,USERPROFILE:r}=G.env;if(typeof t=="string"&&t!=="")return t;if(typeof e=="string"&&e!=="")return E.join(e,M);if(typeof r=="string"&&r!==""&&U.platform()===gt.WIN32)return E.join(r,M);const{homedir:n}=await K();return n},yt=async()=>{const t=await wt();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return y.existsSync(t)||y.mkdirSync(t,{recursive:!0}),t},mt=(t,e)=>{let r="",n=!1;const i=P(t,!0);for(const s of i){if(s.startsWith("fpr:")&&s.includes(`:${e}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){r=s.replace(/(grp|:)/g,"").trim();break}}return r},$t=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:r}=await m(e);return mt(r,t)},ht=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:r}=await m(e),n=P(r,!0),i=[];return n.forEach(s=>{s.startsWith("grp")&&i.push(s.replace(/(grp|:)/g,"").trim())}),i},R=(t,e)=>t.slice(e.length+1).trim(),It=async()=>{const t=["--version"],{stdout:e}=await m(t),r=P(e,!0),n={gnupg:"",libgcrypt:""};return r.forEach(i=>{i.startsWith("gpg (GnuPG) ")?n.gnupg=R(i,"gpg (GnuPG)"):i.startsWith("gpg (GnuPG/MacGPG2) ")?n.gnupg=R(i,"gpg (GnuPG/MacGPG2)"):i.startsWith("libgcrypt ")&&(n.libgcrypt=R(i,"libgcrypt"))}),Object.keys(n).forEach(i=>{const s=n[i];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${i}`,{cause:s})}),n},Et=t=>t.trimStart().startsWith("---"),H=t=>Et(t)?t:Buffer.from(t,"base64").toString(),St=async t=>{const e=H(t),r=await rt.readKey({armoredKey:e}),{user:n}=await r.getPrimaryUser(),i=r.getFingerprint().toUpperCase(),s=r.getKeyID().toHex().toUpperCase(),a=A(nt),{name:u,address:c}=a(n.userID?.userID??"")[0],f=r.getCreationTime();return{digest:i,id:s,name:u,email:c,creationTime:f}},vt=async t=>{const e=E.join(U.tmpdir(),`mnrendra-import-gpg-${C.nanoid()}`),r=y.mkdtempSync(e),n=`${r}/${C.nanoid()}.pgp`,i=H(t);y.writeFileSync(n,i,{mode:384});const s=["--import","--batch","--yes",n],{stdout:a,stderr:u}=await m(s);return u!==""?u:(y.unlinkSync(n),y.rmSync(r),a)},Pt=async()=>{await v("KILLAGENT")},x=async(t,e)=>{const r=Buffer.from(e,"utf8").toString("hex").toUpperCase();return await v(`PRESET_PASSPHRASE ${t} -1 ${r}`),await v(`KEYINFO ${t}`)},Tt=async(t,e)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${e}
y
quit
`);await m(r,{input:n})},S=async(t,e=[])=>await I.execa("git",[t,...e]),_t=(t,{allowEmpty:e=!1,keyid:r,sign:n=!1}={})=>{const i=[];if(n){const s="-S",a=typeof r=="string"&&r!==""?`${s}${r}`:s;i.push(a)}return e&&i.push("--allow-empty"),[...i,"-m",`${t}`]},bt=async(t,e={})=>{const r=_t(t,e);return await S("commit",r)},Nt=(t,{get:e=!1,list:r=!1,unset:n=!1,scope:i="local",value:s}={})=>{const a=[`--${i}`];return s!=null?a.push(`${t}`,`${s.toString()}`):e?a.push("--get",`${t}`):n?a.push("--unset",`${t}`):r&&a.push("--list"),a},O=async(t,e)=>{const r=Nt(t,e);return await S("config",r)},$=async(t,e="local")=>{const{stdout:r}=await O(t,{get:!0,scope:e});if(r==="false")return!1;if(r==="true")return!0;const n=Number(r);return Number.isNaN(n)?r:n},h=async(t,e,r="local")=>await O(t,{scope:r,value:e}),kt=(t,{delete:e=!1,remote:r="origin",signed:n=!1}={})=>{const i=[r,t];return e?[r,"-d",t]:(n!==!1&&i.push(`--signed=${n}`),i)},Rt=async(t,e={})=>{const r=kt(t,e);return await S("push",r)},Ot=(t,{commit:e,delete:r=!1,message:n="",sign:i=!1}={})=>{if(r)return["-d",t];const s=[];return i&&s.push("-s"),s.push(t),e!==void 0&&s.push(e),[...s,"-m",`${n}`]},Ut=async(t,e={})=>{const r=Ot(t,e);return await S("tag",r)},Ct=t=>({value:t,enumerable:!0,configurable:!1,writable:!1}),At=(t,e)=>{Object.keys(e).forEach(r=>{const n=Ct(e[r]);Object.defineProperty(t,r,n)})};At(S,{commit:bt,config:O,getConfig:$,setConfig:h,push:Rt,tag:Ut});const W="user.signingkey",j="user.name",F="user.email",D="commit.gpgsign",q="tag.gpgsign",V="push.gpgsign",Lt=async(t,e,r,{scope:n,signUser:i,signCommit:s,signTag:a,signPush:u})=>{o("---------------- Configuring Git ---------------------------------");const c={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""};return c.scope=n,o(`scope           : ${c.scope}`),i&&(await h(W,t,n),c.userSigningkey=await $(W,n),o(`user.signingkey : ${c.userSigningkey}`),await h(j,e,n),c.userName=await $(j,n),o(`user.name       : ${c.userName}`),await h(F,r,n),c.userEmail=await $(F,n),o(`user.email      : ${c.userEmail}`)),s&&(await h(D,s,n),c.commitGpgsign=await $(D,n),o(`commit.gpgsign  : ${c.commitGpgsign}`)),a&&(await h(q,a,n),c.tagGpgsign=await $(q,n),o(`tag.gpgsign     : ${c.tagGpgsign}`)),u!==!1&&(await h(V,u,n),c.pushGpgsign=await $(V,n),o(`push.gpgsign    : ${c.pushGpgsign}`)),c},Mt=async(t,e,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const i=await yt();if(await lt(i,ut),n.gpgHome=i,o("---------------- Configuring GnuPG agent -------------------------"),o(`GnuPG home      : ${i}`),e!==void 0){o("---------------- Getting keygrip for fingerprint -----------------");const s=await $t(e);o(`Presetting passphrase for key ${e} with keygrip ${s}`);const a=await x(s,r);k(a),n.keygrips=[s]}else{o("---------------- Getting keygrips --------------------------------");const s=await ht(t);for(const a of s){o(`Presetting passphrase for ${a}`);const u=await x(a,r);k(u)}n.keygrips=s}return n},Kt=async()=>{const t=await It(),e=await K(),r={...t,...e};Object.keys(r).forEach(i=>{const s=r[i];if(typeof s!="string"&&s==="")throw new Error(`Invalid GPG ${i} value`,{cause:s})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return o("---------------- GnuPG info --------------------------------------"),o(`Version         : ${n}`),o(`Libdir          : ${r.libdir}`),o(`Libexecdir      : ${r.libexecdir}`),o(`Datadir         : ${r.datadir}`),o(`Homedir         : ${r.homedir}`),{...r,version:n}},Ht=async t=>{const{digest:e,id:r,name:n,email:i,creationTime:s}=await St(t);return o("---------------- GPG private key info ----------------------------"),o(`Fingerprint     : ${e}`),o(`KeyID           : ${r}`),o(`Name            : ${n}`),o(`Email           : ${i}`),o(`CreationTime    : ${s.toUTCString()}`),{digest:e,id:r,name:n,email:i,creationTime:s}},xt=async(t,e)=>{o("---------------- Importing GPG private key -----------------------");const r=await vt(t);return o(r),r},Wt=(t,e)=>{o("---------------- Fingerprint to use ------------------------------"),o(e??t)},T={cwd:G.cwd(),verbose:!1},B=t=>{Object.keys(t).forEach(e=>{T[e]=t[e]})},Y=()=>{const t=G.cwd(),e=T.cwd;t!==e&&(o("---------------- Restore working directory -----------------------"),G.chdir(e),o(`Restore working directory to ${e}.`))},jt=async(t,e)=>{if(e===void 0)return"";const r=Number(e);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:e});return o("---------------- Setting key's trust level ----------------------"),await Tt(t,e),o(`Trust level set to ${e} for ${t}`),`Trust level set to ${e} for ${t}`},Ft=async t=>{const e=G.cwd();B({...T,cwd:e});const r=E.resolve(t);e!==r&&(o("---------------- Change working directory ------------------------"),G.chdir(r),o(`Using ${r} as working directory...`))},Dt=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!Gt(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},qt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},Vt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},Bt=t=>{if(t===void 0)return;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid trustLevel value",{cause:t});return t},Yt=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},zt=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},Xt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},Jt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},Qt=(t=!1)=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},Zt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},te=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const e=Dt(t.workdir),r=qt(t.passphrase),n=Vt(t.fingerprint),i=Bt(t.trustLevel),s=Yt(t.gitScope),a=zt(t.gitSignUser),u=Xt(t.gitSignCommit),c=Jt(t.gitSignTag),f=Qt(t.gitSignPush),d=Zt(t.verbose);return B({...T,verbose:d}),o("---------------- importGPG's options to use ---------------------"),o(`workdir         : ${e}`),o(`passphrase      : ${r}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${i}`),o(`gitScope        : ${s}`),o(`gitSignUser     : ${a}`),o(`gitSignCommit   : ${u}`),o(`gitSignTag      : ${c}`),o(`gitSignPush     : ${f}`),o(`verbose         : ${d}`),{workdir:e,passphrase:r,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:a,gitSignCommit:u,gitSignTag:c,gitSignPush:f,verbose:d}},ee=async(t,e={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const r=te(e),{workdir:n,fingerprint:i,passphrase:s,trustLevel:a}=r;await Ft(n);const u=await Kt(),c=await Ht(t),{digest:f,id:d,name:z,email:X}=c;Wt(f,i);const J=await xt(t),Q=await Mt(f,i,s);await jt(d,a),N("---------------- Successfully set up GPG key ---------------------");const Z={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},w=await Lt(d,z,X,Z);N("---------------- Successfully configured Git ---------------------");const tt={...u,...c,...Q,...w,keyid:d,fingerprint:i??f,log:J,trustLevel:a,gitConfigScope:w.scope,gitUserSigningkey:w.userSigningkey,gitUserName:w.userName,gitUserEmail:w.userEmail,gitCommitGpgsign:w.commitGpgsign,gitTagGpgsign:w.tagGpgsign,gitPushGpgsign:w.pushGpgsign,workdir:G.cwd()};return Y(),tt}catch(r){throw Y(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},re=async(t="")=>{if(t.length<=0){k("Primary key fingerprint is not defined. Skipping cleanup.");return}try{o("---------------- Cleaning up GPG key -----------------------------"),o(`Removing key ${t}`),await pt(t),o("Killing GnuPG agent"),await Pt(),N("---------------- Successfully cleaned up GPG key -----------------")}catch(e){const r=e instanceof Error?e.message:"Unknown error";L(r),L(`${e}`)}},ne=["alpha","beta","rc"],ie=["docs","style","refactor","perf","test","build","ci","chore","revert"],se=ne.map(t=>({name:t,prerelease:!0})),oe=["+([0-9])?(.{+([0-9]),x}).x","main","next",...se],ae=ie.map(t=>({type:t,release:"patch"})),ce="/action",ge=[["@semantic-release/commit-analyzer",{releaseRules:ae}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${ce}/@mnrendra/semantic-release-plugin-github-action`,"@semantic-release/github"],ue={branches:oe,plugins:ge,dryRun:!1,ci:!0},p=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:G.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),le=()=>{const t=l.getInput(g.GPG_FINGERPRINT);if(t===void 0||t==="")return p.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:t});return t},pe=()=>{const t=l.getInput(g.GIT_SCOPE);if(t===void 0||t==="")return p.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:t});return t},fe=()=>{const t=l.getInput(g.GIT_SIGN_COMMIT);if(t===void 0||t==="")return p.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:t})}},Ge=()=>{const t=l.getInput(g.GIT_SIGN_PUSH);if(t===void 0||t==="")return p.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:t})}},de=()=>{const t=l.getInput(g.GIT_SIGN_TAG);if(t===void 0||t==="")return p.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:t})}},we=()=>{const t=l.getInput(g.GIT_SIGN_USER);if(t===void 0||t==="")return p.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:t})}},ye=()=>{const t=l.getInput(g.GPG_PASSPHRASE);if(t===void 0||t==="")return p.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:t});return t},me=()=>{const t=l.getInput(g.GPG_PRIVATE_KEY);if(t===void 0||t==="")return p.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:t});return t},$e=()=>{const t=l.getInput(g.TOKEN);if(t===void 0||t==="")return p.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:t});return t},he=()=>{const t=l.getInput(g.GPG_TRUST_LEVEL);if(t===void 0||t==="")return p.GPG_TRUST_LEVEL;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:t});return e},Ie=()=>{const t=l.getInput(g.WORKDIR);if(t===void 0||t==="")return p.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:t});return t},Ee=()=>{const t=le(),e=pe(),r=fe(),n=Ge(),i=de(),s=we(),a=ye(),u=me(),c=$e(),f=he(),d=Ie();return{fingerprint:t,gitScope:e,gitSignCommit:r,gitSignPush:n,gitSignTag:i,gitSignUser:s,passphrase:a,privateKey:u,token:c,trustLevel:f,workdir:d}},Se=async()=>{await I.execa("git",["config","--global","--add","safe.directory",it]);const t=Ee();let e="",r="GitOps Release",n="gitops-release@users.noreply.github.com",i=G.cwd();const{privateKey:s,token:a}=t;if(s!==void 0){const c=await ee(s,{...t,verbose:!0});e=c.digest,r=c.name,n=c.email,i=c.workdir}const u=await A(et)(ue,{env:{...G.env,GIT_AUTHOR_NAME:r,GIT_AUTHOR_EMAIL:n,GIT_COMMITTER_NAME:r,GIT_COMMITTER_EMAIL:n,GITHUB_TOKEN:a}});return u!==!1?console.log("release:",u.nextRelease.version):console.warn("failed to release!"),await re(e),i};Se().then(t=>{console.log("hasil:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});

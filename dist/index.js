#!/usr/bin/env node
"use strict";var U=require("node:child_process"),d=require("@actions/core"),y=require("node:process"),et=require("semantic-release"),P=require("node:os"),h=require("node:fs"),T=require("node:path"),K=require("nanoid"),rt=require("openpgp"),nt=require("addressparser");const k=(t,e={})=>new Promise((r,n)=>{try{U.exec(t,e,(s,i,g)=>{s!=null&&n(s),r({stdout:i,stderr:g})})}catch(s){n(s)}}),G=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:y.env.GITHUB_TOKEN}),l=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),st=()=>{const t=d.getInput(l.GPG_FINGERPRINT);if(t===void 0||t==="")return G.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_FINGERPRINT} input`,{cause:t});return t},it=()=>{const t=d.getInput(l.GIT_SCOPE);if(t===void 0||t==="")return G.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${l.GIT_SCOPE} input`,{cause:t});return t},ot=()=>{const t=d.getInput(l.GIT_SIGN_COMMIT);if(t===void 0||t==="")return G.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_COMMIT} input`,{cause:t})}},at=()=>{const t=d.getInput(l.GIT_SIGN_PUSH);if(t===void 0||t==="")return G.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${l.GIT_SIGN_PUSH} input`,{cause:t})}},ct=()=>{const t=d.getInput(l.GIT_SIGN_TAG);if(t===void 0||t==="")return G.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_TAG} input`,{cause:t})}},gt=()=>{const t=d.getInput(l.GIT_SIGN_USER);if(t===void 0||t==="")return G.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_USER} input`,{cause:t})}},ut=()=>{const t=d.getInput(l.GPG_PASSPHRASE);if(t===void 0||t==="")return G.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_PASSPHRASE} input`,{cause:t});return t},lt=()=>{const t=d.getInput(l.GPG_PRIVATE_KEY);if(t===void 0||t==="")return G.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_PRIVATE_KEY} input`,{cause:t});return t},pt=()=>{const t=d.getInput(l.TOKEN);if(t===void 0||t==="")return G.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${l.TOKEN} input`,{cause:t});return t},ft=()=>{const t=d.getInput(l.GPG_TRUST_LEVEL);if(t===void 0||t==="")return G.GPG_TRUST_LEVEL;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error(`Invalid ${l.GPG_TRUST_LEVEL} input`,{cause:t});return e},dt=()=>{const t=d.getInput(l.WORKDIR);if(t===void 0||t==="")return G.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${l.WORKDIR} input`,{cause:t});return t},Gt=()=>{const t=st(),e=it(),r=ot(),n=at(),s=ct(),i=gt(),g=ut(),u=lt(),a=pt(),c=ft(),p=dt();return{fingerprint:t,gitScope:e,gitSignCommit:r,gitSignPush:n,gitSignTag:s,gitSignUser:i,passphrase:g,privateKey:u,token:a,trustLevel:c,workdir:p}},wt=t=>{if(typeof t=="function")return t;if(typeof t=="object"&&t!==null&&!Array.isArray(t)&&typeof t.default=="function")return t.default;throw new Error("Invalid module")},yt="/github/workspace",mt=["alpha","beta","rc"],ht=["docs","style","refactor","perf","test","build","ci","chore","revert"],$t=mt.map(t=>({name:t,prerelease:!0})),Et=["+([0-9])?(.{+([0-9]),x}).x","main","next",...$t],It=ht.map(t=>({type:t,release:"patch"})),St="/action",vt=[["@semantic-release/commit-analyzer",{releaseRules:It}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],`${St}/@mnrendra/semantic-release-plugin-publish-github-action`,"@semantic-release/github"],Pt={branches:Et,plugins:vt,dryRun:!1,ci:!0},$={cwd:y.cwd(),verbose:!1},H=t=>{Object.keys(t).forEach(e=>{$[e]=t[e]})},R=(t,e,r="\x1B[39m")=>t.split(`
`).map(n=>(n=e+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),L=t=>{$.verbose&&console.log(R(t,"\x1B[90m"))},_=t=>t.replace(/\r/g,"").trim().split(/\n/),A=(t,e=[],r={})=>new Promise((n,s)=>{try{const i=e.length>0?`${t} ${e.join(" ")}`:t;U.exec(i,r,(g,u,a)=>{g!=null&&s(g);const c=u.trim(),p=_(c),w=a.trim(),m=_(w);n({stdout:c,stdoutLines:p,stderr:w,stderrLines:m})})}catch(i){s(i)}}),o=t=>{$.verbose&&console.log(t)},Tt=t=>{if(typeof t=="function")return t;if(typeof t=="object"&&t!==null&&!Array.isArray(t)&&typeof t.default=="function")return t.default;throw new Error("Invalid module")},x=()=>{const t=y.cwd(),e=$.cwd;t!==e&&(o("---------------- Restore working directory -----------------------"),y.chdir(e),o(`Restore working directory to ${e}.`))},j=(t,e,r)=>{try{let n=e+t.toString(),s=n.indexOf(P.EOL);for(;s>-1;){const i=n.substring(0,s);typeof r=="function"&&r(i),n=n.substring(s+P.EOL.length),s=n.indexOf(P.EOL)}return n}catch(n){throw n instanceof Error?n:new Error("Unknown error",{cause:n})}},_t=(t,e=[],r={})=>new Promise((n,s)=>{try{const i=U.spawn(t,e,r);let g="";i.stdout.on("data",a=>{g=j(a,g)});let u="";i.stderr.on("data",a=>{u=j(a,u)}),i.on("error",a=>{i.removeAllListeners(),s(a)}),i.on("close",a=>{i.removeAllListeners();const c=u.trim(),p=_(c),w=g.trim(),m=_(w);n({code:a,stdout:c,stdoutLines:p,stderr:w,stderrLines:m})}),r.input!==void 0&&i.stdin.end(r.input)}catch(i){s(i)}}),C=t=>{$.verbose&&console.log(R(t,"\x1B[32m"))},Nt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},bt=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},kt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},Rt=(t=!1)=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},At=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},Ot=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},Ut=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},Lt=t=>{if(t===void 0)return;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid trustLevel value",{cause:t});return t},Ct=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},Mt=t=>{try{return h.statSync(t).isDirectory()}catch{return!1}},Kt=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!Mt(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},Ht=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const e=Kt(t.workdir),r=Ut(t.passphrase),n=Nt(t.fingerprint),s=Lt(t.trustLevel),i=bt(t.gitScope),g=Ot(t.gitSignUser),u=kt(t.gitSignCommit),a=At(t.gitSignTag),c=Rt(t.gitSignPush),p=Ct(t.verbose);return H({...$,verbose:p}),o("---------------- importGPG's options to use ---------------------"),o(`workdir         : ${e}`),o(`passphrase      : ${r}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${s}`),o(`gitScope        : ${i}`),o(`gitSignUser     : ${g}`),o(`gitSignCommit   : ${u}`),o(`gitSignTag      : ${a}`),o(`gitSignPush     : ${c}`),o(`verbose         : ${p}`),{workdir:e,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:p}},D=t=>{if($.verbose){const e="\x1B[33m";console.log(R("WARNING:",e)),console.log(R(t,e))}},W=async(t=[])=>await A("git",t),E=async(t,e=!1)=>{const r=["config","--get"];e&&r.push("--global"),r.push(t);const{stdout:n}=await W(r);return n==="true"?!0:n==="false"?!1:n},I=async(t,e,r=!1)=>{const n=["config"];r&&n.push("--global"),n.push(t,e),await W(n)},xt="gpg-agent.conf",jt={RELOADAGENT:"RELOADAGENT"},F=".gnupg",Dt={WIN32:"win32"},Wt=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,O=async t=>{const{stdout:e}=await A(`gpg-connect-agent "${t}" /bye`);return e},Ft=async(t,e)=>{const r=T.join(t,xt);h.writeFileSync(r,e),await O(jt.RELOADAGENT)},S=async(t=[])=>await A("gpg",t),qt=async t=>{const e=["--batch","--yes",t],r=n=>[...e.slice(0,2),n,...e.slice(-1)];await S(r("--delete-secret-keys")),await S(r("--delete-keys"))},Vt=async(t=[])=>await A("gpgconf",t),Bt=(t,e)=>t.slice(e.length+1).replace("%3a",":").trim(),q=async()=>{const{stdoutLines:t}=await Vt(["--list-dirs"]),e={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(r=>{Object.keys(e).forEach(n=>{const s=n;r.startsWith(`${s}:`)&&(e[s]=Bt(r,s))})}),Object.keys(e).forEach(r=>{const n=e[r];if(typeof n!="string"||n==="")throw new Error(`Invalid GPG ${r}`,{cause:n})}),e},Yt=async()=>{const{GNUPGHOME:t,HOME:e,USERPROFILE:r}=y.env;if(typeof t=="string"&&t!=="")return t;if(typeof e=="string"&&e!=="")return T.join(e,F);if(typeof r=="string"&&r!==""&&P.platform()===Dt.WIN32)return T.join(r,F);const{homedir:n}=await q();return n},zt=async()=>{const t=await Yt();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return h.existsSync(t)||h.mkdirSync(t,{recursive:!0}),t},Xt=(t,e)=>{let r="",n=!1;const s=_(t);for(const i of s){if(i.startsWith("fpr:")&&i.includes(`:${e}:`)){n=!0;continue}if(i.startsWith("grp:")&&n){r=i.replace(/(grp|:)/g,"").trim();break}}return r},Jt=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:r}=await S(e);return Xt(r,t)},Qt=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:r}=await S(e),n=[];return r.forEach(s=>{s.startsWith("grp")&&n.push(s.replace(/(grp|:)/g,"").trim())}),n},M=(t,e)=>t.slice(e.length+1).trim(),Zt=async()=>{const t=["--version"],{stdoutLines:e}=await S(t),r={gnupg:"",libgcrypt:""};return e.forEach(n=>{n.startsWith("gpg (GnuPG) ")?r.gnupg=M(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?r.gnupg=M(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(r.libgcrypt=M(n,"libgcrypt"))}),Object.keys(r).forEach(n=>{const s=r[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),r},te=t=>t.trimStart().startsWith("---"),V=t=>te(t)?t:Buffer.from(t,"base64").toString(),ee=async t=>{const e=V(t),r=await rt.readKey({armoredKey:e}),{user:n}=await r.getPrimaryUser(),s=r.getFingerprint().toUpperCase(),i=r.getKeyID().toHex().toUpperCase(),g=Tt(nt),{name:u,address:a}=g(n.userID?.userID??"")[0],c=r.getCreationTime();return{digest:s,id:i,name:u,email:a,creationTime:c}},re=async t=>{const e=T.join(P.tmpdir(),`mnrendra-import-gpg-${K.nanoid()}`),r=h.mkdtempSync(e),n=`${r}/${K.nanoid()}.pgp`,s=V(t);h.writeFileSync(n,s,{mode:384});const i=["--import","--batch","--yes",n],{stdout:g,stderr:u}=await S(i);return u!==""?u:(h.unlinkSync(n),h.rmSync(r),g)},ne=async()=>{await O("KILLAGENT")},B=async(t,e)=>{const r=Buffer.from(e,"utf8").toString("hex").toUpperCase();return await O(`PRESET_PASSPHRASE ${t} -1 ${r}`),await O(`KEYINFO ${t}`)},se=async(t=[],e={})=>await _t("gpg",t,e),ie=async(t,e)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${e}
y
quit
`);await se(r,{input:n})},Y="user.signingkey",z="user.name",X="user.email",J="commit.gpgsign",Q="tag.gpgsign",Z="push.gpgsign",oe=async(t,e,r,{scope:n,signUser:s,signCommit:i,signTag:g,signPush:u})=>{o("---------------- Configuring Git ---------------------------------");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""},c=n==="global";return a.scope=n,o(`scope           : ${a.scope}`),s&&(await I(Y,t,c),a.userSigningkey=await E(Y,c),o(`user.signingkey : ${a.userSigningkey}`),await I(z,e,c),a.userName=await E(z,c),o(`user.name       : ${a.userName}`),await I(X,r,c),a.userEmail=await E(X,c),o(`user.email      : ${a.userEmail}`)),i&&(await I(J,`${i}`,c),a.commitGpgsign=await E(J,c),o(`commit.gpgsign  : ${a.commitGpgsign}`)),g&&(await I(Q,`${g}`,c),a.tagGpgsign=await E(Q,c),o(`tag.gpgsign     : ${a.tagGpgsign}`)),u!==!1&&(await I(Z,`${u}`,c),a.pushGpgsign=await E(Z,c),o(`push.gpgsign    : ${a.pushGpgsign}`)),a},ae=async(t,e,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const s=await zt();if(await Ft(s,Wt),n.gpgHome=s,o("---------------- Configuring GnuPG agent -------------------------"),o(`GnuPG home      : ${s}`),e!==void 0){o("---------------- Getting keygrip for fingerprint -----------------");const i=await Jt(e);o(`Presetting passphrase for key ${e} with keygrip ${i}`);const g=await B(i,r);L(g),n.keygrips=[i]}else{o("---------------- Getting keygrips --------------------------------");const i=await Qt(t);for(const g of i){o(`Presetting passphrase for ${g}`);const u=await B(g,r);L(u)}n.keygrips=i}return n},ce=async()=>{const t=await Zt(),e=await q(),r={...t,...e};Object.keys(r).forEach(s=>{const i=r[s];if(typeof i!="string"&&i==="")throw new Error(`Invalid GPG ${s} value`,{cause:i})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return o("---------------- GnuPG info --------------------------------------"),o(`Version         : ${n}`),o(`Libdir          : ${r.libdir}`),o(`Libexecdir      : ${r.libexecdir}`),o(`Datadir         : ${r.datadir}`),o(`Homedir         : ${r.homedir}`),{...r,version:n}},ge=async t=>{const{digest:e,id:r,name:n,email:s,creationTime:i}=await ee(t);return o("---------------- GPG private key info ----------------------------"),o(`Fingerprint     : ${e}`),o(`KeyID           : ${r}`),o(`Name            : ${n}`),o(`Email           : ${s}`),o(`CreationTime    : ${i.toUTCString()}`),{digest:e,id:r,name:n,email:s,creationTime:i}},ue=async(t,e)=>{o("---------------- Importing GPG private key -----------------------");const r=await re(t);return o(r),r},le=(t,e)=>{o("---------------- Fingerprint to use ------------------------------"),o(e??t)},pe=async(t,e)=>{if(e===void 0)return"";const r=Number(e);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:e});return o("---------------- Setting key's trust level ----------------------"),await ie(t,e),o(`Trust level set to ${e} for ${t}`),`Trust level set to ${e} for ${t}`},fe=async t=>{const e=y.cwd();H({...$,cwd:e});const r=T.resolve(t);e!==r&&(o("---------------- Change working directory ------------------------"),y.chdir(r),o(`Using ${r} as working directory...`))},de=async(t,e={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const r=Ht(e),{workdir:n,fingerprint:s,passphrase:i,trustLevel:g}=r;await fe(n);const u=await ce(),a=await ge(t),{digest:c,id:p,name:w,email:m}=a;le(c,s);const v=await ue(t),N=await ae(c,s,i);await pe(p,g),C("---------------- Successfully set up GPG key ---------------------");const b={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},f=await oe(p,w,m,b);C("---------------- Successfully configured Git ---------------------");const tt={...u,...a,...N,...f,keyid:p,fingerprint:s??c,log:v,trustLevel:g,gitConfigScope:f.scope,gitUserSigningkey:f.userSigningkey,gitUserName:f.userName,gitUserEmail:f.userEmail,gitCommitGpgsign:f.commitGpgsign,gitTagGpgsign:f.tagGpgsign,gitPushGpgsign:f.pushGpgsign,workdir:y.cwd()};return x(),tt}catch(r){throw x(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},Ge=async(t="")=>{if(t.length<=0){L("Primary key fingerprint is not defined. Skipping cleanup.");return}try{o("---------------- Cleaning up GPG key -----------------------------"),o(`Removing key ${t}`),await qt(t),o("Killing GnuPG agent"),await ne(),C("---------------- Successfully cleaned up GPG key -----------------")}catch(e){const r=e instanceof Error?e.message:"Unknown error";D(r),D(`${e}`)}},we=async()=>{await k(`git config --global --add safe.directory ${yt}`);const{workdir:t,privateKey:e,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,token:p}=Gt();let w="",m="GitOps Release",v="gitops-release@users.noreply.github.com",N=y.cwd();if(e!==void 0){const f=await de(e,{workdir:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:i,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:!0});w=f.digest,m=f.name,v=f.email,N=f.workdir}const b=await wt(et)(Pt,{env:{...y.env,GIT_AUTHOR_NAME:m,GIT_AUTHOR_EMAIL:v,GIT_COMMITTER_NAME:m,GIT_COMMITTER_EMAIL:v,GITHUB_TOKEN:p}});return b!==!1?console.log("release:",b.nextRelease.version):console.warn("failed to release!"),await Ge(w),N};console.log("dari index.js:",process.cwd()),console.log("dari index.js:",process.env.NODE_PATH),k("pwd").then(({stderr:t,stdout:e})=>{console.log("stderr:",t),console.log("stdout:",e)}),k("echo $NODE_PATH").then(({stderr:t,stdout:e})=>{console.log("stderr:",t),console.log("stdout:",e)}),k("ls -laihs").then(({stderr:t,stdout:e})=>{console.log("stderr:",t),console.log("stdout:",e)}),we().then(t=>{console.log("hasil:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});

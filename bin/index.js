#!/usr/bin/env node
"use strict";var u=require("node:process"),N=require("node:child_process"),E=require("node:os"),y=require("node:fs"),h=require("node:path"),b=require("nanoid"),B=require("openpgp"),z=require("addressparser"),G=require("@actions/core");const v=t=>t.replace(/\r/g,"").trim().split(/\n/),m=(t,r=[],e={})=>new Promise((n,i)=>{try{const o=r.length>0?`${t} ${r.join(" ")}`:t;N.exec(o,e,(g,p,a)=>{g!=null&&i(g);const c=p.trim(),f=v(c),I=a.trim(),S=v(I);n({stdout:c,stdoutLines:f,stderr:I,stderrLines:S})})}catch(o){i(o)}}),U={cwd:u.cwd(),verbose:!1},X=t=>{Object.keys(t).forEach(r=>{U[r]=t[r]})},s=t=>{U.verbose&&console.log(t)},J=t=>{if(typeof t=="function")return t;if(typeof t=="object"&&t!==null&&!Array.isArray(t)&&typeof t.default=="function")return t.default;throw new Error("Invalid module")},O=(t,r,e)=>{try{let n=r+t.toString(),i=n.indexOf(E.EOL);for(;i>-1;){const o=n.substring(0,i);typeof e=="function"&&e(o),n=n.substring(i+E.EOL.length),i=n.indexOf(E.EOL)}return n}catch(n){throw n instanceof Error?n:new Error("Unknown error",{cause:n})}},Q=(t,r=[],e={})=>new Promise((n,i)=>{try{const o=N.spawn(t,r,e);let g="";o.stdout.on("data",a=>{g=O(a,g)});let p="";o.stderr.on("data",a=>{p=O(a,p)}),o.on("error",a=>{o.removeAllListeners(),i(a)}),o.on("close",a=>{o.removeAllListeners();const c=p.trim(),f=v(c),I=g.trim(),S=v(I);n({code:a,stdout:c,stdoutLines:f,stderr:I,stderrLines:S})}),e.input!==void 0&&o.stdin.end(e.input)}catch(o){i(o)}}),Z=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},tt=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},et=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},rt=(t="if-asked")=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},nt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},it=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},ot=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},st=t=>{if(t===void 0)return;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid trustLevel value",{cause:t});return t},at=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},gt=t=>{try{return y.statSync(t).isDirectory()}catch{return!1}},ct=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!gt(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},ut=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const r=ct(t.workdir),e=ot(t.passphrase),n=Z(t.fingerprint),i=st(t.trustLevel),o=tt(t.gitScope),g=it(t.gitSignUser),p=et(t.gitSignCommit),a=nt(t.gitSignTag),c=rt(t.gitSignPush),f=at(t.verbose);return X({...U,verbose:f}),s("---------------- importGPG's options to use -------------:"),s(`workdir         : ${r}`),s(`passphrase      : ${e}`),s(`fingerprint     : ${n}`),s(`trustLevel      : ${i}`),s(`gitScope        : ${o}`),s(`gitSignUser     : ${g}`),s(`gitSignCommit   : ${p}`),s(`gitSignTag      : ${a}`),s(`gitSignPush     : ${c}`),s(`verbose         : ${f}`),{workdir:r,passphrase:e,fingerprint:n,trustLevel:i,gitScope:o,gitSignUser:g,gitSignCommit:p,gitSignTag:a,gitSignPush:c,verbose:f}},A=async(t=[])=>await m("git",t),T=async(t,r=!1)=>{const e=["config","--get"];r&&e.push("--global"),e.push(t);const{stdout:n}=await A(e);return n==="true"?!0:n==="false"?!1:n},$=async(t,r,e=!1)=>{const n=["config"];e&&n.push("--global"),n.push(t,r),await A(n)},pt="gpg-agent.conf",lt={RELOADAGENT:"RELOADAGENT"},L=".gnupg",ft={WIN32:"win32"},Gt=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,k=async t=>{const{stdout:r}=await m(`gpg-connect-agent "${t}" /bye`);return r},dt=async(t,r)=>{const e=h.join(t,pt);y.writeFileSync(e,r),await k(lt.RELOADAGENT)},_=async(t=[])=>await m("gpg",t),It=async(t=[])=>await m("gpgconf",t),wt=(t,r)=>t.slice(r.length+1).replace("%3a",":").trim(),C=async()=>{const{stdoutLines:t}=await It(["--list-dirs"]),r={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(e=>{Object.keys(r).forEach(n=>{const i=n;e.startsWith(`${i}:`)&&(r[i]=wt(e,i))})}),Object.keys(r).forEach(e=>{const n=r[e];if(typeof n!="string"||n==="")throw new Error(`Invalid GPG ${e}`,{cause:n})}),r},yt=async()=>{const{GNUPGHOME:t,HOME:r,USERPROFILE:e}=u.env;if(typeof t=="string"&&t!=="")return t;if(typeof r=="string"&&r!=="")return h.join(r,L);if(typeof e=="string"&&e!==""&&E.platform()===ft.WIN32)return h.join(e,L);const{homedir:n}=await C();return n},St=async()=>{const t=await yt();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return y.existsSync(t)||y.mkdirSync(t,{recursive:!0}),t},Pt=(t,r)=>{let e="",n=!1;const i=v(t);for(const o of i){if(o.startsWith("fpr:")&&o.includes(`:${r}:`)){n=!0;continue}if(o.startsWith("grp:")&&n){e=o.replace(/(grp|:)/g,"").trim();break}}return e},Tt=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:e}=await _(r);return Pt(e,t)},$t=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:e}=await _(r),n=[];return e.forEach(i=>{i.startsWith("grp")&&n.push(i.replace(/(grp|:)/g,"").trim())}),n},R=(t,r)=>t.slice(r.length+1).trim(),Et=async()=>{const t=["--version"],{stdoutLines:r}=await _(t),e={gnupg:"",libgcrypt:""};return r.forEach(n=>{n.startsWith("gpg (GnuPG) ")?e.gnupg=R(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?e.gnupg=R(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(e.libgcrypt=R(n,"libgcrypt"))}),Object.keys(e).forEach(n=>{const i=e[n];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${n}`,{cause:i})}),e},vt=t=>t.trimStart().startsWith("---"),K=t=>vt(t)?t:Buffer.from(t,"base64").toString(),mt=async t=>{const r=K(t),e=await B.readKey({armoredKey:r}),{user:n}=await e.getPrimaryUser(),i=e.getFingerprint().toUpperCase(),o=e.getKeyID().toHex().toUpperCase(),g=J(z),{name:p,address:a}=g(n.userID?.userID??"")[0],c=e.getCreationTime();return{digest:i,id:o,name:p,email:a,creationTime:c}},ht=async t=>{const r=h.join(E.tmpdir(),`mnrendra-import-gpg-${b.nanoid()}`),e=y.mkdtempSync(r),n=`${e}/${b.nanoid()}.pgp`,i=K(t);y.writeFileSync(n,i,{mode:384});const o=["--import","--batch","--yes",n],{stdout:g,stderr:p}=await _(o);return p!==""?p:(y.unlinkSync(n),y.rmSync(e),g)},H=async(t,r)=>{const e=Buffer.from(r,"utf8").toString("hex").toUpperCase();return await k(`PRESET_PASSPHRASE ${t} -1 ${e}`),await k(`KEYINFO ${t}`)},_t=async(t=[],r={})=>await Q("gpg",t,r),Nt=async(t,r)=>{const e=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${r}
y
quit
`);await _t(e,{input:n})},M="user.signingkey",F="user.name",D="user.email",W="commit.gpgsign",V="tag.gpgsign",j="push.gpgsign",Ut=async(t,r,e,{scope:n,signUser:i,signCommit:o,signTag:g,signPush:p})=>{s("---------------- Git Configs -----------------------------:");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:"if-asked",userName:"",userEmail:""},c=n==="global";return a.scope=n,s(`scope           : ${a.scope}`),i&&(await $(M,t,c),a.userSigningkey=await T(M,c),s(`user.signingkey : ${a.userSigningkey}`),await $(F,r,c),a.userName=await T(F,c),s(`user.name       : ${a.userName}`),await $(D,e,c),a.userEmail=await T(D,c),s(`user.email      : ${a.userEmail}`)),o&&(await $(W,`${o}`,c),a.commitGpgsign=await T(W,c),s(`commit.gpgsign  : ${a.commitGpgsign}`)),g&&(await $(V,`${g}`,c),a.tagGpgsign=await T(V,c),s(`tag.gpgsign     : ${a.tagGpgsign}`)),p!==!1&&(await $(j,`${p}`,c),a.pushGpgsign=await T(j,c),s(`push.gpgsign    : ${a.pushGpgsign}`)),a},kt=async(t,r,e)=>{const n={gpgHome:"",keygripPairs:[]};if(e===void 0)return n;const i=await St();if(await dt(i,Gt),n.gpgHome=i,s("---------------- Configured GnuPG agent ------------------:"),s(`GnuPG home      : ${i}`),r!==void 0){s("---------------- Getting keygrip for fingerprint ---------:");const o=await Tt(r);s(`Presetting passphrase for key ${r} with keygrip ${o}`);const g=await H(o,e);n.keygripPairs=[{keygrip:o,keyinfo:g}]}else{s("---------------- Getting keygrips ------------------------:");const o=await $t(t),g=[];for(const p of o){s(`Presetting passphrase for ${p}`);const a=await H(p,e);g.push({keygrip:p,keyinfo:a})}n.keygripPairs=g}return n},Rt=async()=>{const t=await Et(),r=await C(),e={...t,...r};Object.keys(e).forEach(i=>{const o=e[i];if(typeof o!="string"&&o==="")throw new Error(`Invalid GPG ${i} value`,{cause:o})});const n=`${e.gnupg} (libgcrypt ${e.libgcrypt})`;return s("---------------- GnuPG info ------------------------------:"),s(`Version         : ${n}`),s(`Libdir          : ${e.libdir}`),s(`Libexecdir      : ${e.libexecdir}`),s(`Datadir         : ${e.datadir}`),s(`Homedir         : ${e.homedir}`),{...e,version:n}},bt=async t=>{const{digest:r,id:e,name:n,email:i,creationTime:o}=await mt(t);return s("---------------- GPG private key info --------------------:"),s(`Fingerprint     : ${r}`),s(`KeyID           : ${e}`),s(`Name            : ${n}`),s(`Email           : ${i}`),s(`CreationTime    : ${o.toUTCString()}`),{digest:r,id:e,name:n,email:i,creationTime:o}},Ot=async(t,r)=>{s("---------------- Importing GPG private key ---------------:");const e=await ht(t);return s(e),e},At=(t,r)=>{s("---------------- Fingerprint to use ----------------------:"),s(r??t)},Lt=async(t,r)=>{if(r===void 0)return"";const e=Number(r);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid GPG Trust Level value",{cause:r});return s("---------------- Setting key's trust level --------------:"),await Nt(t,r),s(`Trust level set to ${r} for ${t}`),`Trust level set to ${r} for ${t}`},Ct=async(t,r)=>{console.log("import-gpg-workdir:",u.cwd());const{stderr:e,stdout:n}=await m("ls -laihs");console.log("import-gpg-workdir-stderr:",e),console.log("import-gpg-workdir-stdout:",n),t!=="."&&(s("---------------- Change working directory ----------------:"),u.chdir(t),s(`Using ${t} as working directory...`))},Kt=async(t,r={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const e=ut(r),{workdir:n,fingerprint:i,passphrase:o,trustLevel:g}=e;await Ct(n);const p=await Rt(),a=await bt(t),{digest:c,id:f,name:I,email:S}=a;At(c,i);const x=await Ot(t),q=await kt(c,i,o);await Lt(f,g);const Y={scope:e.gitScope,signUser:e.gitSignUser,signCommit:e.gitSignCommit,signTag:e.gitSignTag,signPush:e.gitSignPush},w=await Ut(f,I,S,Y);return{...p,...a,...q,...w,keyId:a.id,fingerprint:a.digest,log:x,trustLevel:g,gitConfigScope:w.scope,gitUserSigningkey:w.userSigningkey,gitUserName:w.userName,gitUserEmail:w.userEmail,gitCommitGpgsign:w.commitGpgsign,gitTagGpgsign:w.tagGpgsign,gitPushGpgsign:w.pushGpgsign}}catch(e){throw e instanceof Error?e:new Error("Unknown error",{cause:e})}},P=(t,r={})=>new Promise((e,n)=>{try{N.exec(t,r,(i,o,g)=>{i!=null&&n(i),e({stdout:o,stderr:g})})}catch(i){n(i)}}),d=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:"if-asked",TOKEN:u.env.GITHUB_TOKEN}),l=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),Ht=()=>{const t=G.getInput(l.GPG_FINGERPRINT);if(t===void 0||t==="")return d.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_FINGERPRINT} input`,{cause:t});return t},Mt=()=>{const t=G.getInput(l.GIT_SCOPE);if(t===void 0||t==="")return d.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${l.GIT_SCOPE} input`,{cause:t});return t},Ft=()=>{const t=G.getInput(l.GIT_SIGN_COMMIT);if(t===void 0||t==="")return d.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_COMMIT} input`,{cause:t})}},Dt=()=>{const t=G.getInput(l.GIT_SIGN_PUSH);if(t===void 0||t==="")return d.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${l.GIT_SIGN_PUSH} input`,{cause:t})}},Wt=()=>{const t=G.getInput(l.GIT_SIGN_TAG);if(t===void 0||t==="")return d.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_TAG} input`,{cause:t})}},Vt=()=>{const t=G.getInput(l.GIT_SIGN_USER);if(t===void 0||t==="")return d.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${l.GIT_SIGN_USER} input`,{cause:t})}},jt=()=>{const t=G.getInput(l.GPG_PASSPHRASE);if(t===void 0||t==="")return d.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_PASSPHRASE} input`,{cause:t});return t},xt=()=>{const t=G.getInput(l.GPG_PRIVATE_KEY);if(t===void 0||t==="")return d.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${l.GPG_PRIVATE_KEY} input`,{cause:t});return t},qt=()=>{const t=G.getInput(l.TOKEN);if(t===void 0||t==="")return d.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${l.TOKEN} input`,{cause:t});return t},Yt=()=>{const t=G.getInput(l.GPG_TRUST_LEVEL);if(t===void 0||t==="")return d.GPG_TRUST_LEVEL;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error(`Invalid ${l.GPG_TRUST_LEVEL} input`,{cause:t});return r},Bt=()=>{const t=G.getInput(l.WORKDIR);if(t===void 0||t==="")return d.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${l.WORKDIR} input`,{cause:t});return t},zt=()=>{const t=Ht(),r=Mt(),e=Ft(),n=Dt(),i=Wt(),o=Vt(),g=jt(),p=xt(),a=qt(),c=Yt(),f=Bt();return{fingerprint:t,gitScope:r,gitSignCommit:e,gitSignPush:n,gitSignTag:i,gitSignUser:o,passphrase:g,privateKey:p,token:a,trustLevel:c,workdir:f}},Xt=async()=>{console.log("-------main-bagong-------"),await P(`git config --global --add safe.directory ${u.cwd()}`);const{workdir:t,privateKey:r,passphrase:e,fingerprint:n,trustLevel:i,gitScope:o,gitSignUser:g,gitSignCommit:p,gitSignTag:a,gitSignPush:c,token:f}=zt();console.log("workdir:",t,"|",typeof t,"|",`"${u.env.INPUT_WORKDIR}"`,"|",typeof u.env.INPUT_WORKDIR),console.log("privateKey:",r,"|",typeof r,"|",`"${u.env["INPUT_GPG-PRIVATE-KEY"]}"`,"|",typeof u.env["INPUT_GPG-PRIVATE-KEY"]),console.log("passphrase:",e,"|",typeof e,"|",`"${u.env["INPUT_GPG-PASSPHRASE"]}"`,"|",typeof u.env["INPUT_GPG-PASSPHRASE"]),console.log("fingerprint:",n,"|",typeof n,"|",`"${u.env["INPUT_GPG-FINGERPRINT"]}"`,"|",typeof u.env["INPUT_GPG-FINGERPRINT"]),console.log("trustLevel:",i,"|",typeof i,"|",`"${u.env["INPUT_GPG-TRUST-LEVEL"]}"`,"|",typeof u.env["INPUT_GPG-TRUST-LEVEL"]),console.log("gitScope:",o,"|",typeof o,"|",`"${u.env["INPUT_GIT-SCOPE"]}"`,"|",typeof u.env["INPUT_GIT-SCOPE"]),console.log("gitSignUser:",g,"|",typeof g,"|",`"${u.env["INPUT_GIT-SIGN-USER"]}"`,"|",typeof u.env["INPUT_GIT-SIGN-USER"]),console.log("gitSignCommit:",p,"|",typeof p,"|",`"${u.env["INPUT_GIT-SIGN-COMMIT"]}"`,"|",typeof u.env["INPUT_GIT-SIGN-COMMIT"]),console.log("gitSignTag:",a,"|",typeof a,"|",`"${u.env["INPUT_GIT-SIGN-TAG"]}"`,"|",typeof u.env["INPUT_GIT-SIGN-TAG"]),console.log("gitSignPush:",c,"|",typeof c,"|",`"${u.env["INPUT_GIT-SIGN-PUSH"]}"`,"|",typeof u.env["INPUT_GIT-SIGN-PUSH"]),console.log("token:",f,"|",typeof f,"|",`"${u.env.INPUT_TOKEN}"`,"|",typeof u.env.INPUT_TOKEN),console.log(u.cwd());const I=await P("ls -laihs");if(console.log("stderr:",I.stderr),console.log("stdout:",I.stdout),r!==void 0){const S=await Kt(r,{workdir:t,passphrase:e,fingerprint:n,trustLevel:i,gitScope:o,gitSignUser:g,gitSignCommit:p,gitSignTag:a,gitSignPush:c,verbose:!0});console.log("outputs:",S)}await P('echo "tes" >> tes.txt'),await P("git add ."),await P('git commit -S -m "chore: add tes file"'),await P('git tag -s v4.0.0-tes -m "release: v4.0.0-tes"'),await P("git push --follow-tags")};Xt().then(t=>{console.log("result:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});

#!/usr/bin/env node
"use strict";var G=require("node:process"),b=require("node:child_process"),P=require("node:os"),y=require("node:fs"),T=require("node:path"),A=require("nanoid"),tt=require("openpgp"),et=require("addressparser"),f=require("@actions/core");const m={cwd:G.cwd(),verbose:!1},L=t=>{Object.keys(t).forEach(r=>{m[r]=t[r]})},R=t=>{m.verbose&&console.log(`\x1B[90m${t}\x1B[39m`)},_=t=>t.replace(/\r/g,"").trim().split(/\n/),N=(t,r=[],e={})=>new Promise((n,i)=>{try{const s=r.length>0?`${t} ${r.join(" ")}`:t;b.exec(s,e,(g,u,a)=>{g!=null&&i(g);const c=u.trim(),l=_(c),$=a.trim(),v=_($);n({stdout:c,stdoutLines:l,stderr:$,stderrLines:v})})}catch(s){i(s)}}),o=t=>{m.verbose&&console.log(t)},rt=t=>{if(typeof t=="function")return t;if(typeof t=="object"&&t!==null&&!Array.isArray(t)&&typeof t.default=="function")return t.default;throw new Error("Invalid module")},C=()=>{const t=G.cwd(),r=m.cwd;t!==r&&(o("---------------- Restore working directory ---------------:"),G.chdir(r),o(`Restore working directory to ${r}.`))},K=(t,r,e)=>{try{let n=r+t.toString(),i=n.indexOf(P.EOL);for(;i>-1;){const s=n.substring(0,i);typeof e=="function"&&e(s),n=n.substring(i+P.EOL.length),i=n.indexOf(P.EOL)}return n}catch(n){throw n instanceof Error?n:new Error("Unknown error",{cause:n})}},nt=(t,r=[],e={})=>new Promise((n,i)=>{try{const s=b.spawn(t,r,e);let g="";s.stdout.on("data",a=>{g=K(a,g)});let u="";s.stderr.on("data",a=>{u=K(a,u)}),s.on("error",a=>{s.removeAllListeners(),i(a)}),s.on("close",a=>{s.removeAllListeners();const c=u.trim(),l=_(c),$=g.trim(),v=_($);n({code:a,stdout:c,stdoutLines:l,stderr:$,stderrLines:v})}),e.input!==void 0&&s.stdin.end(e.input)}catch(s){i(s)}}),O=t=>{m.verbose&&console.log(`\x1B[32m${t}\x1B[39m`)},it=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},st=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},ot=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},at=(t="if-asked")=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},ct=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},gt=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},ut=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},pt=t=>{if(t===void 0)return;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid trustLevel value",{cause:t});return t},lt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},ft=t=>{try{return y.statSync(t).isDirectory()}catch{return!1}},dt=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!ft(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},Gt=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const r=dt(t.workdir),e=ut(t.passphrase),n=it(t.fingerprint),i=pt(t.trustLevel),s=st(t.gitScope),g=gt(t.gitSignUser),u=ot(t.gitSignCommit),a=ct(t.gitSignTag),c=at(t.gitSignPush),l=lt(t.verbose);return L({...m,verbose:l}),o("---------------- importGPG's options to use -------------:"),o(`workdir         : ${r}`),o(`passphrase      : ${e}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${i}`),o(`gitScope        : ${s}`),o(`gitSignUser     : ${g}`),o(`gitSignCommit   : ${u}`),o(`gitSignTag      : ${a}`),o(`gitSignPush     : ${c}`),o(`verbose         : ${l}`),{workdir:r,passphrase:e,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:l}},x=t=>{m.verbose&&(console.log("\x1B[33mWARNING:\x1B[39m"),console.log(`\x1B[33m${t}\x1B[39m`))},H=async(t=[])=>await N("git",t),h=async(t,r=!1)=>{const e=["config","--get"];r&&e.push("--global"),e.push(t);const{stdout:n}=await H(e);return n==="true"?!0:n==="false"?!1:n},S=async(t,r,e=!1)=>{const n=["config"];e&&n.push("--global"),n.push(t,r),await H(n)},wt="gpg-agent.conf",yt={RELOADAGENT:"RELOADAGENT"},M=".gnupg",mt={WIN32:"win32"},$t=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,k=async t=>{const{stdout:r}=await N(`gpg-connect-agent "${t}" /bye`);return r},ht=async(t,r)=>{const e=T.join(t,wt);y.writeFileSync(e,r),await k(yt.RELOADAGENT)},I=async(t=[])=>await N("gpg",t),St=async t=>{const r=["--batch","--yes",t],e=n=>[...r.slice(0,2),n,...r.slice(-1)];await I(e("--delete-secret-keys")),await I(e("--delete-keys"))},It=async(t=[])=>await N("gpgconf",t),Et=(t,r)=>t.slice(r.length+1).replace("%3a",":").trim(),F=async()=>{const{stdoutLines:t}=await It(["--list-dirs"]),r={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(e=>{Object.keys(r).forEach(n=>{const i=n;e.startsWith(`${i}:`)&&(r[i]=Et(e,i))})}),Object.keys(r).forEach(e=>{const n=r[e];if(typeof n!="string"||n==="")throw new Error(`Invalid GPG ${e}`,{cause:n})}),r},vt=async()=>{const{GNUPGHOME:t,HOME:r,USERPROFILE:e}=G.env;if(typeof t=="string"&&t!=="")return t;if(typeof r=="string"&&r!=="")return T.join(r,M);if(typeof e=="string"&&e!==""&&P.platform()===mt.WIN32)return T.join(e,M);const{homedir:n}=await F();return n},Pt=async()=>{const t=await vt();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return y.existsSync(t)||y.mkdirSync(t,{recursive:!0}),t},Tt=(t,r)=>{let e="",n=!1;const i=_(t);for(const s of i){if(s.startsWith("fpr:")&&s.includes(`:${r}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){e=s.replace(/(grp|:)/g,"").trim();break}}return e},_t=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:e}=await I(r);return Tt(e,t)},Nt=async t=>{const r=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:e}=await I(r),n=[];return e.forEach(i=>{i.startsWith("grp")&&n.push(i.replace(/(grp|:)/g,"").trim())}),n},U=(t,r)=>t.slice(r.length+1).trim(),kt=async()=>{const t=["--version"],{stdoutLines:r}=await I(t),e={gnupg:"",libgcrypt:""};return r.forEach(n=>{n.startsWith("gpg (GnuPG) ")?e.gnupg=U(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?e.gnupg=U(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(e.libgcrypt=U(n,"libgcrypt"))}),Object.keys(e).forEach(n=>{const i=e[n];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${n}`,{cause:i})}),e},bt=t=>t.trimStart().startsWith("---"),W=t=>bt(t)?t:Buffer.from(t,"base64").toString(),Rt=async t=>{const r=W(t),e=await tt.readKey({armoredKey:r}),{user:n}=await e.getPrimaryUser(),i=e.getFingerprint().toUpperCase(),s=e.getKeyID().toHex().toUpperCase(),g=rt(et),{name:u,address:a}=g(n.userID?.userID??"")[0],c=e.getCreationTime();return{digest:i,id:s,name:u,email:a,creationTime:c}},Ot=async t=>{const r=T.join(P.tmpdir(),`mnrendra-import-gpg-${A.nanoid()}`),e=y.mkdtempSync(r),n=`${e}/${A.nanoid()}.pgp`,i=W(t);y.writeFileSync(n,i,{mode:384});const s=["--import","--batch","--yes",n],{stdout:g,stderr:u}=await I(s);return u!==""?u:(y.unlinkSync(n),y.rmSync(e),g)},Ut=async()=>{await k("KILLAGENT")},D=async(t,r)=>{const e=Buffer.from(r,"utf8").toString("hex").toUpperCase();return await k(`PRESET_PASSPHRASE ${t} -1 ${e}`),await k(`KEYINFO ${t}`)},At=async(t=[],r={})=>await nt("gpg",t,r),Lt=async(t,r)=>{const e=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${r}
y
quit
`);await At(e,{input:n})},j="user.signingkey",B="user.name",V="user.email",q="commit.gpgsign",Y="tag.gpgsign",z="push.gpgsign",Ct=async(t,r,e,{scope:n,signUser:i,signCommit:s,signTag:g,signPush:u})=>{o("---------------- Configuring Git -------------------------:");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:"if-asked",userName:"",userEmail:""},c=n==="global";return a.scope=n,o(`scope           : ${a.scope}`),i&&(await S(j,t,c),a.userSigningkey=await h(j,c),o(`user.signingkey : ${a.userSigningkey}`),await S(B,r,c),a.userName=await h(B,c),o(`user.name       : ${a.userName}`),await S(V,e,c),a.userEmail=await h(V,c),o(`user.email      : ${a.userEmail}`)),s&&(await S(q,`${s}`,c),a.commitGpgsign=await h(q,c),o(`commit.gpgsign  : ${a.commitGpgsign}`)),g&&(await S(Y,`${g}`,c),a.tagGpgsign=await h(Y,c),o(`tag.gpgsign     : ${a.tagGpgsign}`)),u!==!1&&(await S(z,`${u}`,c),a.pushGpgsign=await h(z,c),o(`push.gpgsign    : ${a.pushGpgsign}`)),a},Kt=async(t,r,e)=>{const n={gpgHome:"",keygrips:[]};if(e===void 0)return n;const i=await Pt();if(await ht(i,$t),n.gpgHome=i,o("---------------- Configuring GnuPG agent -----------------:"),o(`GnuPG home      : ${i}`),r!==void 0){o("---------------- Getting keygrip for fingerprint ---------:");const s=await _t(r);o(`Presetting passphrase for key ${r} with keygrip ${s}`);const g=await D(s,e);R(g),n.keygrips=[s]}else{o("---------------- Getting keygrips ------------------------:");const s=await Nt(t);for(const g of s){o(`Presetting passphrase for ${g}`);const u=await D(g,e);R(u)}n.keygrips=s}return n},xt=async()=>{const t=await kt(),r=await F(),e={...t,...r};Object.keys(e).forEach(i=>{const s=e[i];if(typeof s!="string"&&s==="")throw new Error(`Invalid GPG ${i} value`,{cause:s})});const n=`${e.gnupg} (libgcrypt ${e.libgcrypt})`;return o("---------------- GnuPG info ------------------------------:"),o(`Version         : ${n}`),o(`Libdir          : ${e.libdir}`),o(`Libexecdir      : ${e.libexecdir}`),o(`Datadir         : ${e.datadir}`),o(`Homedir         : ${e.homedir}`),{...e,version:n}},Ht=async t=>{const{digest:r,id:e,name:n,email:i,creationTime:s}=await Rt(t);return o("---------------- GPG private key info --------------------:"),o(`Fingerprint     : ${r}`),o(`KeyID           : ${e}`),o(`Name            : ${n}`),o(`Email           : ${i}`),o(`CreationTime    : ${s.toUTCString()}`),{digest:r,id:e,name:n,email:i,creationTime:s}},Mt=async(t,r)=>{o("---------------- Importing GPG private key ---------------:");const e=await Ot(t);return o(e),e},Ft=(t,r)=>{o("---------------- Fingerprint to use ----------------------:"),o(r??t)},Wt=async(t,r)=>{if(r===void 0)return"";const e=Number(r);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid GPG Trust Level value",{cause:r});return o("---------------- Setting key's trust level --------------:"),await Lt(t,r),o(`Trust level set to ${r} for ${t}`),`Trust level set to ${r} for ${t}`},Dt=async t=>{const r=G.cwd();L({...m,cwd:r});const e=T.resolve(t);r!==e&&(o("---------------- Change working directory ----------------:"),G.chdir(e),o(`Using ${e} as working directory...`))},jt=async(t,r={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const e=Gt(r),{workdir:n,fingerprint:i,passphrase:s,trustLevel:g}=e;await Dt(n);const u=await xt(),a=await Ht(t),{digest:c,id:l,name:$,email:v}=a;Ft(c,i);const X=await Mt(t),J=await Kt(c,i,s);await Wt(l,g),O("---------------- Successfully set up GPG key -------------:");const Q={scope:e.gitScope,signUser:e.gitSignUser,signCommit:e.gitSignCommit,signTag:e.gitSignTag,signPush:e.gitSignPush},w=await Ct(l,$,v,Q);O("---------------- Successfully configured Git -------------:");const Z={...u,...a,...J,...w,keyid:l,fingerprint:i??c,log:X,trustLevel:g,gitConfigScope:w.scope,gitUserSigningkey:w.userSigningkey,gitUserName:w.userName,gitUserEmail:w.userEmail,gitCommitGpgsign:w.commitGpgsign,gitTagGpgsign:w.tagGpgsign,gitPushGpgsign:w.pushGpgsign,workdir:G.cwd()};return C(),Z}catch(e){throw C(),e instanceof Error?e:new Error("Unknown error",{cause:e})}},Bt=async(t="")=>{if(t.length<=0){R("Primary key fingerprint is not defined. Skipping cleanup.");return}try{o("---------------- Cleaning up GPG key ---------------------:"),o(`Removing key ${t}`),await St(t),o("Killing GnuPG agent"),await Ut(),O("---------------- Successfully cleaned up GPG key ---------:")}catch(r){const e=r instanceof Error?r.message:"Unknown error";x(e),x(r)}},E=(t,r={})=>new Promise((e,n)=>{try{b.exec(t,r,(i,s,g)=>{i!=null&&n(i),e({stdout:s,stderr:g})})}catch(i){n(i)}}),d=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:"if-asked",TOKEN:G.env.GITHUB_TOKEN}),p=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),Vt=()=>{const t=f.getInput(p.GPG_FINGERPRINT);if(t===void 0||t==="")return d.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_FINGERPRINT} input`,{cause:t});return t},qt=()=>{const t=f.getInput(p.GIT_SCOPE);if(t===void 0||t==="")return d.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${p.GIT_SCOPE} input`,{cause:t});return t},Yt=()=>{const t=f.getInput(p.GIT_SIGN_COMMIT);if(t===void 0||t==="")return d.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_COMMIT} input`,{cause:t})}},zt=()=>{const t=f.getInput(p.GIT_SIGN_PUSH);if(t===void 0||t==="")return d.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${p.GIT_SIGN_PUSH} input`,{cause:t})}},Xt=()=>{const t=f.getInput(p.GIT_SIGN_TAG);if(t===void 0||t==="")return d.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_TAG} input`,{cause:t})}},Jt=()=>{const t=f.getInput(p.GIT_SIGN_USER);if(t===void 0||t==="")return d.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_USER} input`,{cause:t})}},Qt=()=>{const t=f.getInput(p.GPG_PASSPHRASE);if(t===void 0||t==="")return d.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_PASSPHRASE} input`,{cause:t});return t},Zt=()=>{const t=f.getInput(p.GPG_PRIVATE_KEY);if(t===void 0||t==="")return d.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_PRIVATE_KEY} input`,{cause:t});return t},te=()=>{const t=f.getInput(p.TOKEN);if(t===void 0||t==="")return d.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${p.TOKEN} input`,{cause:t});return t},ee=()=>{const t=f.getInput(p.GPG_TRUST_LEVEL);if(t===void 0||t==="")return d.GPG_TRUST_LEVEL;const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error(`Invalid ${p.GPG_TRUST_LEVEL} input`,{cause:t});return r},re=()=>{const t=f.getInput(p.WORKDIR);if(t===void 0||t==="")return d.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${p.WORKDIR} input`,{cause:t});return t},ne=()=>{const t=Vt(),r=qt(),e=Yt(),n=zt(),i=Xt(),s=Jt(),g=Qt(),u=Zt(),a=te(),c=ee(),l=re();return{fingerprint:t,gitScope:r,gitSignCommit:e,gitSignPush:n,gitSignTag:i,gitSignUser:s,passphrase:g,privateKey:u,token:a,trustLevel:c,workdir:l}},ie=async()=>{await E(`git config --global --add safe.directory ${G.cwd()}`);const{workdir:t,privateKey:r,passphrase:e,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c}=ne();let l="";r!==void 0&&(l=(await jt(r,{workdir:t,passphrase:e,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:!0})).digest),await E('echo "tes" >> tes.txt'),await E("git add ."),await E('git commit -S -m "chore: add tes file"'),await E('git tag -s v4.5.0-tes -m "release: v4.5.0-tes"'),await E("git push --follow-tags"),await Bt(l)};ie().then(t=>{console.log("result:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});

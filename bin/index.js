#!/usr/bin/env node
"use strict";var G=require("node:process"),b=require("node:child_process"),v=require("node:os"),$=require("node:fs"),P=require("node:path"),O=require("nanoid"),J=require("openpgp"),Q=require("addressparser"),f=require("@actions/core");const T=t=>t.replace(/\r/g,"").trim().split(/\n/),N=(t,e=[],r={})=>new Promise((n,i)=>{try{const s=e.length>0?`${t} ${e.join(" ")}`:t;b.exec(s,r,(g,u,a)=>{g!=null&&i(g);const c=u.trim(),l=T(c),w=a.trim(),E=T(w);n({stdout:c,stdoutLines:l,stderr:w,stderrLines:E})})}catch(s){i(s)}}),_={cwd:G.cwd(),verbose:!1},U=t=>{Object.keys(t).forEach(e=>{_[e]=t[e]})},o=t=>{_.verbose&&console.log(t)},Z=t=>{if(typeof t=="function")return t;if(typeof t=="object"&&t!==null&&!Array.isArray(t)&&typeof t.default=="function")return t.default;throw new Error("Invalid module")},A=()=>{const t=G.cwd(),e=_.cwd;t!==e&&(o("---------------- Restore working directory ---------------:"),G.chdir(e),o(`Restore working directory to ${e}.`))},L=(t,e,r)=>{try{let n=e+t.toString(),i=n.indexOf(v.EOL);for(;i>-1;){const s=n.substring(0,i);typeof r=="function"&&r(s),n=n.substring(i+v.EOL.length),i=n.indexOf(v.EOL)}return n}catch(n){throw n instanceof Error?n:new Error("Unknown error",{cause:n})}},tt=(t,e=[],r={})=>new Promise((n,i)=>{try{const s=b.spawn(t,e,r);let g="";s.stdout.on("data",a=>{g=L(a,g)});let u="";s.stderr.on("data",a=>{u=L(a,u)}),s.on("error",a=>{s.removeAllListeners(),i(a)}),s.on("close",a=>{s.removeAllListeners();const c=u.trim(),l=T(c),w=g.trim(),E=T(w);n({code:a,stdout:c,stdoutLines:l,stderr:w,stderrLines:E})}),r.input!==void 0&&s.stdin.end(r.input)}catch(s){i(s)}}),rt=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid fingerprint value",{cause:t});return t}},et=(t="local")=>{if(typeof t!="string"||!["global","local"].includes(t))throw new Error("Invalid gitScope value",{cause:t});return t},nt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignCommit value",{cause:t});return t},it=(t="if-asked")=>{if(typeof t!="boolean"&&(typeof t!="string"||t!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:t});return t},st=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignTag value",{cause:t});return t},ot=(t=!0)=>{if(typeof t!="boolean")throw new Error("Invalid gitSignUser value",{cause:t});return t},at=t=>{if(t!==void 0){if(typeof t!="string"||t==="")throw new Error("Invalid passphrase value",{cause:t});return t}},ct=t=>{if(t===void 0)return;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error("Invalid trustLevel value",{cause:t});return t},gt=(t=!1)=>{if(typeof t!="boolean")throw new Error("Invalid verbose value",{cause:t});return t},ut=t=>{try{return $.statSync(t).isDirectory()}catch{return!1}},pt=(t=".")=>{if(typeof t!="string"||t==="")throw new Error("Invalid workdir value",{cause:t});if(!ut(t))throw new Error(`workdir ${t} is doesn't exist`,{cause:t});return t},lt=t=>{if(typeof t!="object"||t===null||Array.isArray(t))throw new Error("Invalid options value",{cause:t});const e=pt(t.workdir),r=at(t.passphrase),n=rt(t.fingerprint),i=ct(t.trustLevel),s=et(t.gitScope),g=ot(t.gitSignUser),u=nt(t.gitSignCommit),a=st(t.gitSignTag),c=it(t.gitSignPush),l=gt(t.verbose);return U({..._,verbose:l}),o("---------------- importGPG's options to use -------------:"),o(`workdir         : ${e}`),o(`passphrase      : ${r}`),o(`fingerprint     : ${n}`),o(`trustLevel      : ${i}`),o(`gitScope        : ${s}`),o(`gitSignUser     : ${g}`),o(`gitSignCommit   : ${u}`),o(`gitSignTag      : ${a}`),o(`gitSignPush     : ${c}`),o(`verbose         : ${l}`),{workdir:e,passphrase:r,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:l}},C=async(t=[])=>await N("git",t),m=async(t,e=!1)=>{const r=["config","--get"];e&&r.push("--global"),r.push(t);const{stdout:n}=await C(r);return n==="true"?!0:n==="false"?!1:n},h=async(t,e,r=!1)=>{const n=["config"];r&&n.push("--global"),n.push(t,e),await C(n)},ft="gpg-agent.conf",dt={RELOADAGENT:"RELOADAGENT"},K=".gnupg",wt={WIN32:"win32"},Gt=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,k=async t=>{const{stdout:e}=await N(`gpg-connect-agent "${t}" /bye`);return e},yt=async(t,e)=>{const r=P.join(t,ft);$.writeFileSync(r,e),await k(dt.RELOADAGENT)},S=async(t=[])=>await N("gpg",t),$t=async t=>{const e=["--batch","--yes",t],r=n=>[...e.slice(0,2),n,...e.slice(-1)];await S(r("--delete-secret-keys")),await S(r("--delete-keys"))},mt=async(t=[])=>await N("gpgconf",t),ht=(t,e)=>t.slice(e.length+1).replace("%3a",":").trim(),H=async()=>{const{stdoutLines:t}=await mt(["--list-dirs"]),e={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(r=>{Object.keys(e).forEach(n=>{const i=n;r.startsWith(`${i}:`)&&(e[i]=ht(r,i))})}),Object.keys(e).forEach(r=>{const n=e[r];if(typeof n!="string"||n==="")throw new Error(`Invalid GPG ${r}`,{cause:n})}),e},St=async()=>{const{GNUPGHOME:t,HOME:e,USERPROFILE:r}=G.env;if(typeof t=="string"&&t!=="")return t;if(typeof e=="string"&&e!=="")return P.join(e,K);if(typeof r=="string"&&r!==""&&v.platform()===wt.WIN32)return P.join(r,K);const{homedir:n}=await H();return n},It=async()=>{const t=await St();if(t.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:t});return $.existsSync(t)||$.mkdirSync(t,{recursive:!0}),t},Et=(t,e)=>{let r="",n=!1;const i=T(t);for(const s of i){if(s.startsWith("fpr:")&&s.includes(`:${e}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){r=s.replace(/(grp|:)/g,"").trim();break}}return r},vt=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdout:r}=await S(e);return Et(r,t)},Pt=async t=>{const e=["--batch","--with-colons","--with-keygrip","--list-secret-keys",t],{stdoutLines:r}=await S(e),n=[];return r.forEach(i=>{i.startsWith("grp")&&n.push(i.replace(/(grp|:)/g,"").trim())}),n},R=(t,e)=>t.slice(e.length+1).trim(),Tt=async()=>{const t=["--version"],{stdoutLines:e}=await S(t),r={gnupg:"",libgcrypt:""};return e.forEach(n=>{n.startsWith("gpg (GnuPG) ")?r.gnupg=R(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?r.gnupg=R(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(r.libgcrypt=R(n,"libgcrypt"))}),Object.keys(r).forEach(n=>{const i=r[n];if(typeof i!="string"||i==="")throw new Error(`Invalid GPG ${n}`,{cause:i})}),r},_t=t=>t.trimStart().startsWith("---"),M=t=>_t(t)?t:Buffer.from(t,"base64").toString(),Nt=async t=>{const e=M(t),r=await J.readKey({armoredKey:e}),{user:n}=await r.getPrimaryUser(),i=r.getFingerprint().toUpperCase(),s=r.getKeyID().toHex().toUpperCase(),g=Z(Q),{name:u,address:a}=g(n.userID?.userID??"")[0],c=r.getCreationTime();return{digest:i,id:s,name:u,email:a,creationTime:c}},kt=async t=>{const e=P.join(v.tmpdir(),`mnrendra-import-gpg-${O.nanoid()}`),r=$.mkdtempSync(e),n=`${r}/${O.nanoid()}.pgp`,i=M(t);$.writeFileSync(n,i,{mode:384});const s=["--import","--batch","--yes",n],{stdout:g,stderr:u}=await S(s);return u!==""?u:($.unlinkSync(n),$.rmSync(r),g)},bt=async()=>{await k("KILLAGENT")},F=async(t,e)=>{const r=Buffer.from(e,"utf8").toString("hex").toUpperCase();return await k(`PRESET_PASSPHRASE ${t} -1 ${r}`),await k(`KEYINFO ${t}`)},Rt=async(t=[],e={})=>await tt("gpg",t,e),Ot=async(t,e)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",t],n=Buffer.from(`trust
${e}
y
quit
`);await Rt(r,{input:n})},W="user.signingkey",D="user.name",j="user.email",x="commit.gpgsign",V="tag.gpgsign",q="push.gpgsign",Ut=async(t,e,r,{scope:n,signUser:i,signCommit:s,signTag:g,signPush:u})=>{o("---------------- Git Configs -----------------------------:");const a={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:"if-asked",userName:"",userEmail:""},c=n==="global";return a.scope=n,o(`scope           : ${a.scope}`),i&&(await h(W,t,c),a.userSigningkey=await m(W,c),o(`user.signingkey : ${a.userSigningkey}`),await h(D,e,c),a.userName=await m(D,c),o(`user.name       : ${a.userName}`),await h(j,r,c),a.userEmail=await m(j,c),o(`user.email      : ${a.userEmail}`)),s&&(await h(x,`${s}`,c),a.commitGpgsign=await m(x,c),o(`commit.gpgsign  : ${a.commitGpgsign}`)),g&&(await h(V,`${g}`,c),a.tagGpgsign=await m(V,c),o(`tag.gpgsign     : ${a.tagGpgsign}`)),u!==!1&&(await h(q,`${u}`,c),a.pushGpgsign=await m(q,c),o(`push.gpgsign    : ${a.pushGpgsign}`)),a},At=async(t,e,r)=>{const n={gpgHome:"",keygripPairs:[]};if(r===void 0)return n;const i=await It();if(await yt(i,Gt),n.gpgHome=i,o("---------------- Configured GnuPG agent ------------------:"),o(`GnuPG home      : ${i}`),e!==void 0){o("---------------- Getting keygrip for fingerprint ---------:");const s=await vt(e);o(`Presetting passphrase for key ${e} with keygrip ${s}`);const g=await F(s,r);n.keygripPairs=[{keygrip:s,keyinfo:g}]}else{o("---------------- Getting keygrips ------------------------:");const s=await Pt(t),g=[];for(const u of s){o(`Presetting passphrase for ${u}`);const a=await F(u,r);g.push({keygrip:u,keyinfo:a})}n.keygripPairs=g}return n},Lt=async()=>{const t=await Tt(),e=await H(),r={...t,...e};Object.keys(r).forEach(i=>{const s=r[i];if(typeof s!="string"&&s==="")throw new Error(`Invalid GPG ${i} value`,{cause:s})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return o("---------------- GnuPG info ------------------------------:"),o(`Version         : ${n}`),o(`Libdir          : ${r.libdir}`),o(`Libexecdir      : ${r.libexecdir}`),o(`Datadir         : ${r.datadir}`),o(`Homedir         : ${r.homedir}`),{...r,version:n}},Ct=async t=>{const{digest:e,id:r,name:n,email:i,creationTime:s}=await Nt(t);return o("---------------- GPG private key info --------------------:"),o(`Fingerprint     : ${e}`),o(`KeyID           : ${r}`),o(`Name            : ${n}`),o(`Email           : ${i}`),o(`CreationTime    : ${s.toUTCString()}`),{digest:e,id:r,name:n,email:i,creationTime:s}},Kt=async(t,e)=>{o("---------------- Importing GPG private key ---------------:");const r=await kt(t);return o(r),r},Ht=(t,e)=>{o("---------------- Fingerprint to use ----------------------:"),o(e??t)},Mt=async(t,e)=>{if(e===void 0)return"";const r=Number(e);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:e});return o("---------------- Setting key's trust level --------------:"),await Ot(t,e),o(`Trust level set to ${e} for ${t}`),`Trust level set to ${e} for ${t}`},Ft=async t=>{const e=G.cwd();U({..._,cwd:e});const r=P.resolve(t);e!==r&&(o("---------------- Change working directory ----------------:"),G.chdir(r),o(`Using ${r} as working directory...`))},Wt=async(t,e={})=>{try{if(typeof t!="string"||t==="")throw new Error("Invalid GnuPG private key",{cause:t});const r=lt(e),{workdir:n,fingerprint:i,passphrase:s,trustLevel:g}=r;await Ft(n);const u=await Lt(),a=await Ct(t),{digest:c,id:l,name:w,email:E}=a;Ht(c,i);const Y=await Kt(t),B=await At(c,i,s);await Mt(l,g);const z={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},y=await Ut(l,w,E,z),X={...u,...a,...B,...y,keyid:l,fingerprint:i??c,log:Y,trustLevel:g,gitConfigScope:y.scope,gitUserSigningkey:y.userSigningkey,gitUserName:y.userName,gitUserEmail:y.userEmail,gitCommitGpgsign:y.commitGpgsign,gitTagGpgsign:y.tagGpgsign,gitPushGpgsign:y.pushGpgsign,workdir:G.cwd()};return A(),X}catch(r){throw A(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},Dt=async(t="")=>{if(t.length<=0){console.log("Primary key fingerprint is not defined. Skipping cleanup.");return}try{console.log(`Removing key ${t}`),await $t(t),console.log("Killing GnuPG agent"),await bt()}catch(e){const r=e instanceof Error?e.message:"Unknown error";console.warn("WARNING:",r),console.warn(e)}},I=(t,e={})=>new Promise((r,n)=>{try{b.exec(t,e,(i,s,g)=>{i!=null&&n(i),r({stdout:s,stderr:g})})}catch(i){n(i)}}),d=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:"if-asked",TOKEN:G.env.GITHUB_TOKEN}),p=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),jt=()=>{const t=f.getInput(p.GPG_FINGERPRINT);if(t===void 0||t==="")return d.GPG_FINGERPRINT;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_FINGERPRINT} input`,{cause:t});return t},xt=()=>{const t=f.getInput(p.GIT_SCOPE);if(t===void 0||t==="")return d.GIT_SCOPE;if(typeof t!="string"||!["global","local"].includes(t))throw new Error(`Invalid ${p.GIT_SCOPE} input`,{cause:t});return t},Vt=()=>{const t=f.getInput(p.GIT_SIGN_COMMIT);if(t===void 0||t==="")return d.GIT_SIGN_COMMIT;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_COMMIT} input`,{cause:t})}},qt=()=>{const t=f.getInput(p.GIT_SIGN_PUSH);if(t===void 0||t==="")return d.GIT_SIGN_PUSH;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${p.GIT_SIGN_PUSH} input`,{cause:t})}},Yt=()=>{const t=f.getInput(p.GIT_SIGN_TAG);if(t===void 0||t==="")return d.GIT_SIGN_TAG;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_TAG} input`,{cause:t})}},Bt=()=>{const t=f.getInput(p.GIT_SIGN_USER);if(t===void 0||t==="")return d.GIT_SIGN_USER;if(typeof t=="boolean")return t;switch(t){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${p.GIT_SIGN_USER} input`,{cause:t})}},zt=()=>{const t=f.getInput(p.GPG_PASSPHRASE);if(t===void 0||t==="")return d.GPG_PASSPHRASE;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_PASSPHRASE} input`,{cause:t});return t},Xt=()=>{const t=f.getInput(p.GPG_PRIVATE_KEY);if(t===void 0||t==="")return d.GPG_PRIVATE_KEY;if(typeof t!="string")throw new Error(`Invalid ${p.GPG_PRIVATE_KEY} input`,{cause:t});return t},Jt=()=>{const t=f.getInput(p.TOKEN);if(t===void 0||t==="")return d.TOKEN;if(typeof t!="string")throw new Error(`Invalid ${p.TOKEN} input`,{cause:t});return t},Qt=()=>{const t=f.getInput(p.GPG_TRUST_LEVEL);if(t===void 0||t==="")return d.GPG_TRUST_LEVEL;const e=Number(t);if(Number.isNaN(e)||e<1||e>5)throw new Error(`Invalid ${p.GPG_TRUST_LEVEL} input`,{cause:t});return e},Zt=()=>{const t=f.getInput(p.WORKDIR);if(t===void 0||t==="")return d.WORKDIR;if(typeof t!="string")throw new Error(`Invalid ${p.WORKDIR} input`,{cause:t});return t},tr=()=>{const t=jt(),e=xt(),r=Vt(),n=qt(),i=Yt(),s=Bt(),g=zt(),u=Xt(),a=Jt(),c=Qt(),l=Zt();return{fingerprint:t,gitScope:e,gitSignCommit:r,gitSignPush:n,gitSignTag:i,gitSignUser:s,passphrase:g,privateKey:u,token:a,trustLevel:c,workdir:l}},rr=async()=>{await I(`git config --global --add safe.directory ${G.cwd()}`);const{workdir:t,privateKey:e,passphrase:r,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c}=tr();let l="";if(e!==void 0){const w=await Wt(e,{workdir:t,passphrase:r,fingerprint:n,trustLevel:i,gitScope:s,gitSignUser:g,gitSignCommit:u,gitSignTag:a,gitSignPush:c,verbose:!0});l=w.digest,console.log("outputs:",w)}await I('echo "tes" >> tes.txt'),await I("git add ."),await I('git commit -S -m "chore: add tes file"'),await I('git tag -s v4.3.0-tes -m "release: v4.3.0-tes"'),await I("git push --follow-tags"),await Dt(l)};rr().then(t=>{console.log("result:",t)}).catch(t=>{throw t instanceof Error?t:new Error("Unknown error")});
